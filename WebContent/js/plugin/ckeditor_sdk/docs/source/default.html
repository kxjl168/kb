<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='global-property-'>/**
</span> * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* globals CKEDITOR */

( function() {
	var List,
		Style,
		Heuristics,
		filter,
		tools = CKEDITOR.tools,
		invalidTags = [
			&#39;o:p&#39;,
			&#39;xml&#39;,
			&#39;script&#39;,
			&#39;meta&#39;,
			&#39;link&#39;
		],
		shapeTags = [
			&#39;v:arc&#39;,
			&#39;v:curve&#39;,
			&#39;v:line&#39;,
			&#39;v:oval&#39;,
			&#39;v:polyline&#39;,
			&#39;v:rect&#39;,
			&#39;v:roundrect&#39;,
			&#39;v:group&#39;
		],
		links = {},
		inComment = 0;

<span id='CKEDITOR-plugins-property-pastefromword'>	/**
</span>	 * Set of Paste from Word plugin helpers.
	 *
	 * @since 4.6.0
	 * @private
	 * @member CKEDITOR.plugins
	 */
	CKEDITOR.plugins.pastefromword = {};

	CKEDITOR.cleanWord = function( mswordHtml, editor ) {
		var msoListsDetected = Boolean( mswordHtml.match( /mso-list:\s*l\d+\s+level\d+\s+lfo\d+/ ) ),
			shapesIds = [];

		function shapeTagging( element ) {
			// Check if regular or canvas shape (#1088).
			if ( element.attributes[ &#39;o:gfxdata&#39; ] || element.parent.name === &#39;v:group&#39; ) {
				shapesIds.push( element.attributes.id );
			}
		}

		// Before filtering inline all the styles to allow because some of them are available only in style
		// sheets. This step is skipped in IEs due to their flaky support for custom types in dataTransfer. (https://dev.ckeditor.com/ticket/16847)
		if ( CKEDITOR.plugins.clipboard.isCustomDataTypesSupported ) {
			mswordHtml = CKEDITOR.plugins.pastefromword.styles.inliner.inline( mswordHtml ).getBody().getHtml();
		}

		// Sometimes Word malforms the comments.
		mswordHtml = mswordHtml.replace( /&lt;!\[/g, &#39;&lt;!--[&#39; ).replace( /\]&gt;/g, &#39;]--&gt;&#39; );

		var fragment = CKEDITOR.htmlParser.fragment.fromHtml( mswordHtml );

		var filterDefinition = {
			root: function( element ) {
				element.filterChildren( filter );

				CKEDITOR.plugins.pastefromword.lists.cleanup( List.createLists( element ) );
			},
			elementNames: [
				[ ( /^\?xml:namespace$/ ), &#39;&#39; ],
				[ /^v:shapetype/, &#39;&#39; ],
				[ new RegExp( invalidTags.join( &#39;|&#39; ) ), &#39;&#39; ] // Remove invalid tags.
			],
			elements: {
				&#39;a&#39;: function( element ) {
					// Redundant anchor created by IE8.
					if ( element.attributes.name ) {
						if ( element.attributes.name == &#39;_GoBack&#39; ) {
							delete element.name;
							return;
						}

						// Garbage links that go nowhere.
						if ( element.attributes.name.match( /^OLE_LINK\d+$/ ) ) {
							delete element.name;
							return;
						}
					}

					if ( element.attributes.href &amp;&amp; element.attributes.href.match( /#.+$/ ) ) {
						var name = element.attributes.href.match( /#(.+)$/ )[ 1 ];
						links[ name ] = element;
					}

					if ( element.attributes.name &amp;&amp;  links[ element.attributes.name ] ) {
						var link = links[ element.attributes.name ];
						link.attributes.href = link.attributes.href.replace( /.*#(.*)$/, &#39;#$1&#39; );
					}

				},
				&#39;div&#39;: function( element ) {
					Style.createStyleStack( element, filter, editor );
				},
				&#39;img&#39;: function( element ) {
					var attributeStyleMap = {
						width: function( value ) {
							Style.setStyle( element, &#39;width&#39;, value + &#39;px&#39; );
						},
						height: function( value ) {
							Style.setStyle( element, &#39;height&#39;, value + &#39;px&#39; );
						}
					};

					// If the parent is DocumentFragment it does not have any attributes. (https://dev.ckeditor.com/ticket/16912)
					if ( element.parent &amp;&amp; element.parent.attributes ) {
						var attrs = element.parent.attributes,
							style = attrs.style || attrs.STYLE;
						if ( style &amp;&amp; style.match( /mso\-list:\s?Ignore/ ) ) {
							element.attributes[ &#39;cke-ignored&#39; ] = true;
						}
					}

					Style.mapStyles( element, attributeStyleMap );

					if ( element.attributes.src &amp;&amp; element.attributes.src.match( /^file:\/\// ) &amp;&amp;
						element.attributes.alt &amp;&amp; element.attributes.alt.match( /^https?:\/\// ) ) {
						element.attributes.src = element.attributes.alt;
					}

					var imgShapesIds = element.attributes[ &#39;v:shapes&#39; ] ? element.attributes[ &#39;v:shapes&#39; ].split( &#39; &#39; ) : [];
					// Check whether attribute contains shapes recognised earlier (stored in global list of shapesIds).
					// If so, add additional data-attribute to img tag.
					var isShapeFromList = CKEDITOR.tools.array.every( imgShapesIds, function( shapeId ) {
						return shapesIds.indexOf( shapeId ) &gt; -1;
					} );
					if ( imgShapesIds.length &amp;&amp; isShapeFromList ) {
						// As we don&#39;t know how to process shapes we can remove them.
						return false;
					}

				},
				&#39;p&#39;: function( element ) {
					element.filterChildren( filter );

					if ( element.attributes.style &amp;&amp; element.attributes.style.match( /display:\s*none/i ) ) {
						return false;
					}

					if ( List.thisIsAListItem( editor, element ) ) {
						if ( Heuristics.isEdgeListItem( editor, element ) ) {
							Heuristics.cleanupEdgeListItem( element );
						}

						List.convertToFakeListItem( editor, element );

						// IE pastes nested paragraphs in list items, which is different from other browsers. (https://dev.ckeditor.com/ticket/16826)
						// There&#39;s a possibility that list item will contain multiple paragraphs, in that case we want
						// to split them with BR.
						tools.array.reduce( element.children, function( paragraphsReplaced, node ) {
							if ( node.name === &#39;p&#39; ) {
								// If there were already paragraphs replaced, put a br before this paragraph, so that
								// it&#39;s inline children are displayed in a next line.
								if ( paragraphsReplaced &gt; 0 ) {
									var br = new CKEDITOR.htmlParser.element( &#39;br&#39; );
									br.insertBefore( node );
								}

								node.replaceWithChildren();
								paragraphsReplaced += 1;
							}

							return paragraphsReplaced;
						}, 0 );
					} else {
						// In IE list level information is stored in &lt;p&gt; elements inside &lt;li&gt; elements.
						var container = element.getAscendant( function( element ) {
								return element.name == &#39;ul&#39; || element.name == &#39;ol&#39;;
							} ),
							style = tools.parseCssText( element.attributes.style );
						if ( container &amp;&amp;
							!container.attributes[ &#39;cke-list-level&#39; ] &amp;&amp;
							style[ &#39;mso-list&#39; ] &amp;&amp;
							style[ &#39;mso-list&#39; ].match( /level/ ) ) {
							container.attributes[ &#39;cke-list-level&#39; ] = style[ &#39;mso-list&#39; ].match( /level(\d+)/ )[1];
						}

						// Adapt paragraph formatting to editor&#39;s convention according to enter-mode (#423).
						if ( editor.config.enterMode == CKEDITOR.ENTER_BR ) {
							// We suffer from attribute/style lost in this situation.
							delete element.name;
							element.add( new CKEDITOR.htmlParser.element( &#39;br&#39; ) );
						}

					}

					Style.createStyleStack( element, filter, editor );
				},
				&#39;pre&#39;: function( element ) {
					if ( List.thisIsAListItem( editor, element ) ) List.convertToFakeListItem( editor, element );

					Style.createStyleStack( element, filter, editor );
				},
				&#39;h1&#39;: function( element ) {
					if ( List.thisIsAListItem( editor, element ) ) List.convertToFakeListItem( editor, element );

					Style.createStyleStack( element, filter, editor );
				},
				&#39;h2&#39;: function( element ) {
					if ( List.thisIsAListItem( editor, element ) ) List.convertToFakeListItem( editor, element );

					Style.createStyleStack( element, filter, editor );
				},
				&#39;h3&#39;: function( element ) {
					if ( List.thisIsAListItem( editor, element ) ) List.convertToFakeListItem( editor, element );

					Style.createStyleStack( element, filter, editor );
				},
				&#39;h4&#39;: function( element ) {
					if ( List.thisIsAListItem( editor, element ) ) List.convertToFakeListItem( editor, element );

					Style.createStyleStack( element, filter, editor );
				},
				&#39;h5&#39;: function( element ) {
					if ( List.thisIsAListItem( editor, element ) ) List.convertToFakeListItem( editor, element );

					Style.createStyleStack( element, filter, editor );
				},
				&#39;h6&#39;: function( element ) {
					if ( List.thisIsAListItem( editor, element ) ) List.convertToFakeListItem( editor, element );

					Style.createStyleStack( element, filter, editor );
				},
				&#39;font&#39;: function( element ) {
					if ( element.getHtml().match( /^\s*$/ ) ) {
						new CKEDITOR.htmlParser.text( &#39; &#39; ).insertAfter( element );
						return false;
					}

					if ( editor &amp;&amp; editor.config.pasteFromWordRemoveFontStyles === true &amp;&amp; element.attributes.size ) {
						// font[size] are still used by old IEs for font size.
						delete element.attributes.size;
					}

					// Create style stack for td/th &gt; font if only class
					// and style attributes are present. Such markup is produced by Excel.
					if ( CKEDITOR.dtd.tr[ element.parent.name ] &amp;&amp;
						CKEDITOR.tools.arrayCompare( CKEDITOR.tools.objectKeys( element.attributes ), [ &#39;class&#39;, &#39;style&#39; ] ) ) {

						Style.createStyleStack( element, filter, editor );
					} else {
						createAttributeStack( element, filter );
					}
				},
				&#39;ul&#39;: function( element ) {
					if ( !msoListsDetected ) {
						// List should only be processed if we&#39;re sure we&#39;re working with Word. (https://dev.ckeditor.com/ticket/16593)
						return;
					}

					// Edge case from 11683 - an unusual way to create a level 2 list.
					if ( element.parent.name == &#39;li&#39; &amp;&amp; tools.indexOf( element.parent.children, element ) === 0 ) {
						Style.setStyle( element.parent, &#39;list-style-type&#39;, &#39;none&#39; );
					}

					List.dissolveList( element );
					return false;
				},
				&#39;li&#39;: function( element ) {
					Heuristics.correctLevelShift( element );

					if ( !msoListsDetected ) {
						return;
					}

					element.attributes.style = Style.normalizedStyles( element, editor );

					Style.pushStylesLower( element );
				},
				&#39;ol&#39;: function( element ) {
					if ( !msoListsDetected ) {
						// List should only be processed if we&#39;re sure we&#39;re working with Word. (https://dev.ckeditor.com/ticket/16593)
						return;
					}

					// Fix edge-case where when a list skips a level in IE11, the &lt;ol&gt; element
					// is implicitly surrounded by a &lt;li&gt;.
					if ( element.parent.name == &#39;li&#39; &amp;&amp; tools.indexOf( element.parent.children, element ) === 0 ) {
						Style.setStyle( element.parent, &#39;list-style-type&#39;, &#39;none&#39; );
					}

					List.dissolveList( element );
					return false;
				},
				&#39;span&#39;: function( element ) {
					element.filterChildren( filter );

					element.attributes.style = Style.normalizedStyles( element, editor );

					if ( !element.attributes.style ||
							// Remove garbage bookmarks that disrupt the content structure.
						element.attributes.style.match( /^mso\-bookmark:OLE_LINK\d+$/ ) ||
						element.getHtml().match( /^(\s|&amp;nbsp;)+$/ ) ) {

						// replaceWithChildren doesn&#39;t work in filters.
						for ( var i = element.children.length - 1; i &gt;= 0; i-- ) {
							element.children[ i ].insertAfter( element );
						}
						return false;
					}

					if ( element.attributes.style.match( /FONT-FAMILY:\s*Symbol/i ) ) {
						element.forEach( function( node ) {
							node.value = node.value.replace( /&amp;nbsp;/g, &#39;&#39; );
						}, CKEDITOR.NODE_TEXT, true );
					}

					Style.createStyleStack( element, filter, editor );
				},
				&#39;table&#39;: function( element ) {
					element._tdBorders = {};
					element.filterChildren( filter );

					var borderStyle, occurences = 0;
					for ( var border in element._tdBorders ) {
						if ( element._tdBorders[ border ] &gt; occurences ) {
							occurences = element._tdBorders[ border ];
							borderStyle = border;
						}
					}

					Style.setStyle( element, &#39;border&#39;, borderStyle );

					var parent = element.parent,
						root = parent &amp;&amp; parent.parent,
						parentChildren,
						i;

					// In case parent div has only align attr, move it to the table element (https://dev.ckeditor.com/ticket/16811).
					if ( parent.name &amp;&amp; parent.name === &#39;div&#39; &amp;&amp; parent.attributes.align &amp;&amp;
						tools.objectKeys( parent.attributes ).length === 1 &amp;&amp; parent.children.length === 1 ) {
						// If align is the only attribute of parent.
						element.attributes.align = parent.attributes.align;

						parentChildren = parent.children.splice( 0 );

						element.remove();
						for ( i = parentChildren.length - 1; i &gt;= 0; i-- ) {
							root.add( parentChildren[ i ], parent.getIndex() );
						}
						parent.remove();
					}

				},
				&#39;td&#39;: function( element ) {

					var ascendant = element.getAscendant( &#39;table&#39; ),
						tdBorders =  ascendant._tdBorders,
						borderStyles = [ &#39;border&#39;, &#39;border-top&#39;, &#39;border-right&#39;, &#39;border-bottom&#39;, &#39;border-left&#39; ],
						ascendantStyle = tools.parseCssText( ascendant.attributes.style );

					// Sometimes the background is set for the whole table - move it to individual cells.
					var background = ascendantStyle.background || ascendantStyle.BACKGROUND;
					if ( background ) {
						Style.setStyle( element, &#39;background&#39;, background, true );
					}

					var backgroundColor = ascendantStyle[ &#39;background-color&#39; ] || ascendantStyle[ &#39;BACKGROUND-COLOR&#39; ];
					if ( backgroundColor ) {
						Style.setStyle( element, &#39;background-color&#39;, backgroundColor, true );
					}

					var styles = tools.parseCssText( element.attributes.style );

					for ( var style in styles ) {
						var temp = styles[ style ];
						delete styles[ style ];
						styles[ style.toLowerCase() ] = temp;
					}

					// Count all border styles that occur in the table.
					for ( var i = 0; i &lt; borderStyles.length; i++ ) {
						if ( styles[ borderStyles[ i ] ] ) {
							var key = styles[ borderStyles[ i ] ];
							tdBorders[ key ] = tdBorders[ key ] ? tdBorders[ key ] + 1 : 1;
						}
					}

					Style.createStyleStack( element, filter, editor,
						/margin|text\-align|padding|list\-style\-type|width|height|border|white\-space|vertical\-align|background/i );
				},
				&#39;v:imagedata&#39;: remove,
				// This is how IE8 presents images.
				&#39;v:shape&#39;: function( element ) {
					// There are 3 paths:
					// 1. There is regular `v:shape` (no `v:imagedata` inside).
					// 2. There is a simple situation with `v:shape` with `v:imagedata` inside. We can remove such element and rely on `img` tag found later on.
					// 3. There is a complicated situation where we cannot find proper `img` tag after `v:shape` or there is some canvas element.
					// 		a) If shape is a child of v:group, then most probably it belongs to canvas, so we need to treat it as in path 1.
					// 		b) In other cases, most probably there is no related `img` tag. We need to transform `v:shape` into `img` tag (IE8 integration).

					var duplicate = false,
						child = element.getFirst( &#39;v:imagedata&#39; );

					// Path 1:
					if ( child === null ) {
						shapeTagging( element );
						return;
					}

					// Path 2:
					// Sometimes a child with proper ID might be nested in other tag.
					element.parent.find( function( child ) {
						if ( child.name == &#39;img&#39; &amp;&amp; child.attributes &amp;&amp;
							child.attributes[ &#39;v:shapes&#39; ] == element.attributes.id ) {

							duplicate = true;
						}
					}, true );

					if ( duplicate ) {
						return false;
					} else {

						// Path 3:
						var src = &#39;&#39;;

						// 3.a) Filter out situation when canvas is used. In such scenario there is v:group containing v:shape containing v:imagedata.
						// We streat such v:shapes as in Path 1.
						if ( element.parent.name === &#39;v:group&#39; ) {
							shapeTagging( element );
							return;
						}

						// 3.b) Most probably there is no img tag later on, so we need to transform this v:shape into img. This should only happen on IE8.
						element.forEach( function( child ) {
							if ( child.attributes &amp;&amp; child.attributes.src ) {
								src = child.attributes.src;
							}
						}, CKEDITOR.NODE_ELEMENT, true );

						element.filterChildren( filter );

						element.name = &#39;img&#39;;
						element.attributes.src = element.attributes.src || src;

						delete element.attributes.type;
					}

					return;
				},

				&#39;style&#39;: function() {
					// We don&#39;t want to let any styles in. Firefox tends to add some.
					return false;
				},

				&#39;object&#39;: function( element ) {
					// The specs about object `data` attribute:
					// 		Address of the resource as a valid URL. At least one of data and type must be defined.
					// If there is not `data`, skip the object element. (https://dev.ckeditor.com/ticket/17001)
					return !!( element.attributes &amp;&amp; element.attributes.data );
				}
			},
			attributes: {
				&#39;style&#39;: function( styles, element ) {
					// Returning false deletes the attribute.
					return Style.normalizedStyles( element, editor ) || false;
				},
				&#39;class&#39;: function( classes ) {
					// The (el\d+)|(font\d+) are default Excel classes for table cells and text.
					return falseIfEmpty( classes.replace( /(el\d+)|(font\d+)|msonormal|msolistparagraph\w*/ig, &#39;&#39; ) );
				},
				&#39;cellspacing&#39;: remove,
				&#39;cellpadding&#39;: remove,
				&#39;border&#39;: remove,
				&#39;v:shapes&#39;: remove,
				&#39;o:spid&#39;: remove
			},
			comment: function( element ) {
				if ( element.match( /\[if.* supportFields.*\]/ ) ) {
					inComment++;
				}
				if ( element == &#39;[endif]&#39; ) {
					inComment = inComment &gt; 0 ? inComment - 1 : 0;
				}
				return false;
			},
			text: function( content, node ) {
				if ( inComment ) {
					return &#39;&#39;;
				}

				var grandparent = node.parent &amp;&amp; node.parent.parent;

				if ( grandparent &amp;&amp; grandparent.attributes &amp;&amp; grandparent.attributes.style &amp;&amp; grandparent.attributes.style.match( /mso-list:\s*ignore/i ) ) {
					return content.replace( /&amp;nbsp;/g, &#39; &#39; );
				}

				return content;
			}
		};

		// Add shape processing to filter definition.
		CKEDITOR.tools.array.forEach( shapeTags, function( shapeTag ) {
			filterDefinition.elements[ shapeTag ] = shapeTagging;
		} );

		filter = new CKEDITOR.htmlParser.filter( filterDefinition );

		var writer = new CKEDITOR.htmlParser.basicWriter();

		filter.applyTo( fragment );

		fragment.writeHtml( writer );

		return writer.getHtml();
	};

<span id='CKEDITOR-plugins-pastefromword-property-styles'>	/**
</span>	 * Namespace containing all the helper functions to work with styles.
	 *
	 * @private
	 * @since 4.6.0
	 * @member CKEDITOR.plugins.pastefromword
	 */
	CKEDITOR.plugins.pastefromword.styles = {
		setStyle: function( element, key, value, dontOverwrite ) {
			var styles = tools.parseCssText( element.attributes.style );

			if ( dontOverwrite &amp;&amp; styles[ key ] ) {
				return;
			}

			if ( value === &#39;&#39; ) {
				delete styles[ key ];
			} else {
				styles[ key ] = value;
			}

			element.attributes.style = CKEDITOR.tools.writeCssText( styles );
		},

		// Map attributes to styles.
		mapStyles: function( element, attributeStyleMap ) {
			for ( var attribute in attributeStyleMap ) {
				if ( element.attributes[ attribute ] ) {
					if ( typeof attributeStyleMap[ attribute ] === &#39;function&#39; ) {
						attributeStyleMap[ attribute ]( element.attributes[ attribute ] );
					} else {
						Style.setStyle( element, attributeStyleMap[ attribute ], element.attributes[ attribute ] );
					}
					delete element.attributes[ attribute ];
				}
			}
		},

<span id='CKEDITOR-plugins-pastefromword-styles-method-normalizedStyles'>		/**
</span>		 * Filters Word-specific styles for a given element. Also might filter additional styles
		 * based on the `editor` configuration.
		 *
		 * @private
		 * @param {CKEDITOR.htmlParser.element} element
		 * @param {CKEDITOR.editor} editor
		 * @member CKEDITOR.plugins.pastefromword.styles
		 */
		normalizedStyles: function( element, editor ) {

			// Some styles and style values are redundant, so delete them.
			var resetStyles = [
					&#39;background-color:transparent&#39;,
					&#39;border-image:none&#39;,
					&#39;color:windowtext&#39;,
					&#39;direction:ltr&#39;,
					&#39;mso-&#39;,
					&#39;text-indent&#39;,
					&#39;visibility:visible&#39;,
					&#39;div:border:none&#39; // This one stays because https://dev.ckeditor.com/ticket/6241
				],
				textStyles = [
					&#39;font-family&#39;,
					&#39;font&#39;,
					&#39;font-size&#39;,
					&#39;color&#39;,
					&#39;background-color&#39;,
					&#39;line-height&#39;,
					&#39;text-decoration&#39;
				],
				matchStyle = function() {
					var keys = [];
					for ( var i = 0; i &lt; arguments.length; i++ ) {
						if ( arguments[ i ] ) {
							keys.push( arguments[ i ] );
						}
					}

					return tools.indexOf( resetStyles, keys.join( &#39;:&#39; ) ) !== -1;
				},
				removeFontStyles = editor &amp;&amp; editor.config.pasteFromWordRemoveFontStyles === true;

			var styles = tools.parseCssText( element.attributes.style );

			if ( element.name == &#39;cke:li&#39; ) {
				// IE8 tries to emulate list indentation with a combination of
				// text-indent and left margin. Normalize this. Note that IE8 styles are uppercase.
				if ( styles[ &#39;TEXT-INDENT&#39; ] &amp;&amp; styles.MARGIN ) {
					element.attributes[ &#39;cke-indentation&#39; ] = List.getElementIndentation( element );
					styles.MARGIN = styles.MARGIN.replace( /(([\w\.]+ ){3,3})[\d\.]+(\w+$)/, &#39;$10$3&#39; );
				}

			}

			var keys = tools.objectKeys( styles );

			for ( var i = 0; i &lt; keys.length; i++ ) {
				var styleName = keys[ i ].toLowerCase(),
					styleValue = styles[ keys[ i ] ],
					indexOf = CKEDITOR.tools.indexOf,
					toBeRemoved = removeFontStyles &amp;&amp; indexOf( textStyles, styleName.toLowerCase() ) !== -1;

				if ( toBeRemoved || matchStyle( null, styleName, styleValue ) ||
					matchStyle( null, styleName.replace( /\-.*$/, &#39;-&#39; ) ) ||
					matchStyle( null, styleName ) ||
					matchStyle( element.name, styleName, styleValue ) ||
					matchStyle( element.name, styleName.replace( /\-.*$/, &#39;-&#39; ) ) ||
					matchStyle( element.name, styleName ) ||
					matchStyle( styleValue )
				) {
					delete styles[ keys[ i ] ];
				}
			}
			return CKEDITOR.tools.writeCssText( styles );
		},

<span id='CKEDITOR-plugins-pastefromword-styles-method-createStyleStack'>		/**
</span>		 * Surrounds the element&#39;s children with a stack of spans, each one having one style
		 * originally belonging to the element.
		 *
		 * @private
		 * @param {CKEDITOR.htmlParser.element} element
		 * @param {CKEDITOR.htmlParser.filter} filter
		 * @param {CKEDITOR.editor} editor
		 * @param {RegExp} [skipStyles] All matching style names will not be extracted to a style stack. Defaults
		 * to `/margin|text\-align|width|border|padding/i`.
		 * @member CKEDITOR.plugins.pastefromword.styles
		 */
		createStyleStack: function( element, filter, editor, skipStyles ) {
			var children = [],
				i;

			element.filterChildren( filter );

			// Store element&#39;s children somewhere else.
			for ( i = element.children.length - 1; i &gt;= 0; i-- ) {
				children.unshift( element.children[ i ] );
				element.children[ i ].remove();
			}

			Style.sortStyles( element );

			// Create a stack of spans with each containing one style.
			var styles = tools.parseCssText( Style.normalizedStyles( element, editor ) ),
				innermostElement = element,
				styleTopmost = element.name === &#39;span&#39;; // Ensure that the root element retains at least one style.

			for ( var style in styles ) {
				if ( style.match( skipStyles || /margin|text\-align|width|border|padding/i ) ) {
					continue;
				}

				if ( styleTopmost ) {
					styleTopmost = false;
					continue;
				}

				var newElement = new CKEDITOR.htmlParser.element( &#39;span&#39; );

				newElement.attributes.style = style + &#39;:&#39; + styles[ style ];

				innermostElement.add( newElement );
				innermostElement = newElement;

				delete styles[ style ];
			}

			if ( !CKEDITOR.tools.isEmpty( styles ) ) {
				element.attributes.style = CKEDITOR.tools.writeCssText( styles );
			} else {
				delete element.attributes.style;
			}

			// Add the stored children to the innermost span.
			for ( i = 0; i &lt; children.length; i++ ) {
				innermostElement.add( children[ i ] );
			}
		},

		// Some styles need to be stacked in a particular order to work properly.
		sortStyles: function( element ) {
			var orderedStyles = [
					&#39;border&#39;,
					&#39;border-bottom&#39;,
					&#39;font-size&#39;,
					&#39;background&#39;
				],
				style = tools.parseCssText( element.attributes.style ),
				keys = tools.objectKeys( style ),
				sortedKeys = [],
				nonSortedKeys = [];

			// Divide styles into sorted and non-sorted, because Array.prototype.sort()
			// requires a transitive relation.
			for ( var i = 0; i &lt; keys.length; i++ ) {
				if ( tools.indexOf( orderedStyles, keys[ i ].toLowerCase() ) !== -1 ) {
					sortedKeys.push( keys[ i ] );
				} else {
					nonSortedKeys.push( keys[ i ] );
				}
			}

			// For styles in orderedStyles[] enforce the same order as in orderedStyles[].
			sortedKeys.sort( function( a, b ) {
				var aIndex = tools.indexOf( orderedStyles, a.toLowerCase() );
				var bIndex = tools.indexOf( orderedStyles, b.toLowerCase() );

				return aIndex - bIndex;
			} );

			keys = [].concat( sortedKeys, nonSortedKeys );

			var sortedStyles = {};

			for ( i = 0; i &lt; keys.length; i++ ) {
				sortedStyles[ keys[ i ] ] = style[ keys[ i ] ];
			}

			element.attributes.style = CKEDITOR.tools.writeCssText( sortedStyles );
		},

<span id='CKEDITOR-plugins-pastefromword-styles-method-pushStylesLower'>		/**
</span>		 * Moves the element&#39;s styles lower in the DOM hierarchy. If `wrapText==true` and the direct child of an element
		 * is a text node it will be wrapped in a `span` element.
		 *
		 * @param {CKEDITOR.htmlParser.element} element
		 * @param {Object} exceptions An object containing style names which should not be moved, e.g. `{ background: true }`.
		 * @param {Boolean} [wrapText=false] Whether a direct text child of an element should be wrapped into a `span` tag
		 * so that the styles can be moved to it.
		 * @returns {Boolean} Returns `true` if styles were successfully moved lower.
		 * @member CKEDITOR.plugins.pastefromword.styles
		 */
		pushStylesLower: function( element, exceptions, wrapText ) {

			if ( !element.attributes.style ||
				element.children.length === 0 ) {
				return false;
			}

			exceptions = exceptions || {};

			// Entries ending with a dash match styles that start with
			// the entry name, e.g. &#39;border-&#39; matches &#39;border-style&#39;, &#39;border-color&#39; etc.
			var retainedStyles = {
				&#39;list-style-type&#39;: true,
				&#39;width&#39;: true,
				&#39;height&#39;: true,
				&#39;border&#39;: true,
				&#39;border-&#39;: true
			};

			var styles = tools.parseCssText( element.attributes.style );

			for ( var style in styles ) {
				if ( style.toLowerCase() in retainedStyles ||
					retainedStyles [ style.toLowerCase().replace( /\-.*$/, &#39;-&#39; ) ] ||
					style.toLowerCase() in exceptions ) {
					continue;
				}

				var pushed = false;

				for ( var i = 0; i &lt; element.children.length; i++ ) {
					var child = element.children[ i ];

					if ( child.type === CKEDITOR.NODE_TEXT &amp;&amp; wrapText ) {
						var wrapper = new CKEDITOR.htmlParser.element( &#39;span&#39; );
						wrapper.setHtml( child.value );
						child.replaceWith( wrapper );
						child = wrapper;
					}

					if ( child.type !== CKEDITOR.NODE_ELEMENT ) {
						continue;
					}

					pushed = true;

					Style.setStyle( child, style, styles[ style ] );
				}

				if ( pushed ) {
					delete styles[ style ];
				}
			}

			element.attributes.style = CKEDITOR.tools.writeCssText( styles );

			return true;
		},

<span id='CKEDITOR-plugins-pastefromword-styles-property-inliner'>		/**
</span>		 * Namespace containing the styles inliner.
		 *
		 * @since 4.7.0
		 * @private
		 * @member CKEDITOR.plugins.pastefromword.styles
		 */
		inliner: {
<span id='CKEDITOR-plugins-pastefromword-styles-inliner-property-filtered'>			/**
</span>			 *
			 * Styles skipped by the styles inliner.
			 *
			 * @property {String[]}
			 * @private
			 * @member CKEDITOR.plugins.pastefromword.styles.inliner
			 */
			filtered: [
				&#39;break-before&#39;,
				&#39;break-after&#39;,
				&#39;break-inside&#39;,
				&#39;page-break&#39;,
				&#39;page-break-before&#39;,
				&#39;page-break-after&#39;,
				&#39;page-break-inside&#39;
			],

<span id='CKEDITOR-plugins-pastefromword-styles-inliner-method-parse'>			/**
</span>			 * Parses the content of the provided `style` element.
			 *
			 * @param {CKEDITOR.dom.element/String} styles The `style` element or CSS text.
			 * @returns {Array} An array containing parsed styles. Each item (style) is an object containing two properties:
			 * 		selector &amp;ndash; A string representing a CSS selector.
			 * 		styles &amp;ndash; An object containing a list of styles (e.g. `{ margin: 0, text-align: &#39;left&#39; }`).
			 * @since 4.7.0
			 * @private
			 * @member CKEDITOR.plugins.pastefromword.styles.inliner
			 */
			parse: function( styles ) {
				var parseCssText = CKEDITOR.tools.parseCssText,
					filterStyles = CKEDITOR.plugins.pastefromword.styles.inliner.filter,
					sheet = styles.is ? styles.$.sheet : createIsolatedStylesheet( styles );

				function createIsolatedStylesheet( styles ) {
					var style = new CKEDITOR.dom.element( &#39;style&#39; ),
						iframe = new CKEDITOR.dom.element( &#39;iframe&#39; );

					iframe.hide();
					CKEDITOR.document.getBody().append( iframe );
					iframe.$.contentDocument.documentElement.appendChild( style.$ );

					style.$.textContent = styles;
					iframe.remove();
					return style.$.sheet;
				}

				function getStyles( cssText ) {
					var startIndex = cssText.indexOf( &#39;{&#39; ),
						endIndex = cssText.indexOf( &#39;}&#39; );

					return parseCssText( cssText.substring( startIndex + 1, endIndex ), true );
				}

				var parsedStyles = [],
					rules,
					i;

				if ( sheet ) {
					rules = sheet.cssRules;

					for ( i = 0; i &lt; rules.length; i++ ) {
						// To detect if the rule contains styles and is not an at-rule, it&#39;s enough to check rule&#39;s type.
						if ( rules[ i ].type === window.CSSRule.STYLE_RULE ) {
							parsedStyles.push( {
								selector: rules[ i ].selectorText,
								styles: filterStyles( getStyles( rules[ i ].cssText ) )
							} );
						}
					}
				}
				return parsedStyles;
			},

<span id='CKEDITOR-plugins-pastefromword-styles-inliner-method-filter'>			/**
</span>			 * Filters out all unnecessary styles.
			 *
			 * @param {Object} stylesObj An object containing parsed CSS declarations
			 * as property/value pairs (see {@link CKEDITOR.plugins.pastefromword.styles.inliner#parse}).
			 * @returns {Object} The `stylesObj` copy with specific styles filtered out.
			 * @since 4.7.0
			 * @private
			 * @member CKEDITOR.plugins.pastefromword.styles.inliner
			 */
			filter: function( stylesObj ) {
				var toRemove = CKEDITOR.plugins.pastefromword.styles.inliner.filtered,
					indexOf = tools.array.indexOf,
					newObj = {},
					style;

				for ( style in stylesObj ) {
					if ( indexOf( toRemove, style ) === -1 ) {
						newObj[ style ] = stylesObj[ style ];
					}
				}

				return newObj;
			},

<span id='CKEDITOR-plugins-pastefromword-styles-inliner-method-sort'>			/**
</span>			 * Sorts the given styles array. All rules containing class selectors will have lower indexes than the rest
			 * of the rules. Selectors with the same priority will be sorted in a reverse order than in the input array.
			 *
			 * @param {Array} stylesArray An array of styles as returned from
			 * {@link CKEDITOR.plugins.pastefromword.styles.inliner#parse}.
			 * @returns {Array} Sorted stylesArray.
			 * @since 4.7.0
			 * @private
			 * @member CKEDITOR.plugins.pastefromword.styles.inliner
			 */
			sort: function( stylesArray ) {

				// Returns comparison function which sorts all selectors in a way that class selectors are ordered
				// before the rest of the selectors. The order of the selectors with the same specificity
				// is reversed so that the most important will be applied first.
				function getCompareFunction( styles ) {
					var order = CKEDITOR.tools.array.map( styles, function( item ) {
						return item.selector;
					} );

					return function( style1, style2 ) {
						var value1 = isClassSelector( style1.selector ) ? 1 : 0,
							value2 = isClassSelector( style2.selector ) ? 1 : 0,
							result = value2 - value1;

						// If the selectors have same specificity, the latter one should
						// have higher priority (goes first).
						return result !== 0 ? result :
							order.indexOf( style2.selector ) - order.indexOf( style1.selector );
					};
				}

				// True if given CSS selector contains a class selector.
				function isClassSelector( selector ) {
					return ( &#39;&#39; + selector ).indexOf( &#39;.&#39; ) !== -1;
				}

				return stylesArray.sort( getCompareFunction( stylesArray ) );
			},

<span id='CKEDITOR-plugins-pastefromword-styles-inliner-method-inline'>			/**
</span>			 * Finds and inlines all the `style` elements in a given `html` string and returns a document where
			 * all the styles are inlined into appropriate elements.
			 *
			 * This is needed because sometimes Microsoft Word does not put the style directly into the element, but
			 * into a generic style sheet.
			 *
			 * @param {String} html An HTML string to be parsed.
			 * @returns {CKEDITOR.dom.document}
			 * @since 4.7.0
			 * @private
			 * @member CKEDITOR.plugins.pastefromword.styles.inliner
			 */
			inline: function( html ) {
				var parseStyles = CKEDITOR.plugins.pastefromword.styles.inliner.parse,
					sortStyles = CKEDITOR.plugins.pastefromword.styles.inliner.sort,
					document = createTempDocument( html ),
					stylesTags = document.find( &#39;style&#39; ),
					stylesArray = sortStyles( parseStyleTags( stylesTags ) );

				function createTempDocument( html ) {
					var parser = new DOMParser(),
						document = parser.parseFromString( html, &#39;text/html&#39; );

					return new CKEDITOR.dom.document( document );
				}

				function parseStyleTags( stylesTags ) {
					var styles = [],
						i;

					for ( i = 0; i &lt; stylesTags.count(); i++ ) {
						styles = styles.concat( parseStyles( stylesTags.getItem( i ) ) );
					}

					return styles;
				}

				function applyStyle( document, selector, style ) {
					var elements = document.find( selector ),
						element,
						oldStyle,
						newStyle,
						i;

					for ( i = 0; i &lt; elements.count(); i++ ) {
						element = elements.getItem( i );

						oldStyle = CKEDITOR.tools.parseCssText( element.getAttribute( &#39;style&#39; ) );
						// The styles are applied with decreasing priority so we do not want
						// to overwrite the existing properties.
						newStyle = CKEDITOR.tools.extend( {}, oldStyle, style );
						element.setAttribute( &#39;style&#39;, CKEDITOR.tools.writeCssText( newStyle ) );
					}
				}

				CKEDITOR.tools.array.forEach( stylesArray, function( style ) {
					applyStyle( document, style.selector, style.styles );
				} );

				return document;
			}
		}
	};
	Style = CKEDITOR.plugins.pastefromword.styles;

<span id='CKEDITOR-plugins-pastefromword-property-lists'>	/**
</span>	 * Namespace containing any list-oriented helper methods.
	 *
	 * @private
	 * @since 4.6.0
	 * @member CKEDITOR.plugins.pastefromword
	 */
	CKEDITOR.plugins.pastefromword.lists = {
<span id='CKEDITOR-plugins-pastefromword-lists-method-thisIsAListItem'>		/**
</span>		 * Checks if a given element is a list item-alike.
		 *
		 * @private
		 * @param {CKEDITOR.editor} editor
		 * @param {CKEDITOR.htmlParser.element} element
		 * @returns {Boolean}
		 * @member CKEDITOR.plugins.pastefromword.lists
		 */
		thisIsAListItem: function( editor, element ) {
			if ( Heuristics.isEdgeListItem( editor, element ) ) {
				return true;
			}

			/*jshint -W024 */
			// Normally a style of the sort that looks like &quot;mso-list: l0 level1 lfo1&quot;
			// indicates a list element, but the same style may appear in a &lt;p&gt; that&#39;s within a &lt;li&gt;.
			if ( ( element.attributes.style &amp;&amp; element.attributes.style.match( /mso\-list:\s?l\d/ ) &amp;&amp;
				element.parent.name !== &#39;li&#39; ) ||
				element.attributes[ &#39;cke-dissolved&#39; ] ||
				element.getHtml().match( /&lt;!\-\-\[if !supportLists]\-\-&gt;/ )
			) {
				return true;
			}

			return false;
			/*jshint +W024 */
		},

<span id='CKEDITOR-plugins-pastefromword-lists-method-convertToFakeListItem'>		/**
</span>		 * Converts an element to an element with the `cke:li` tag name.
		 *
		 * @private
		 * @param {CKEDITOR.editor} editor
		 * @param {CKEDITOR.htmlParser.element} element
		 * @member CKEDITOR.plugins.pastefromword.lists
		 */
		convertToFakeListItem: function( editor, element ) {
			if ( Heuristics.isDegenerateListItem( editor, element ) ) {
				Heuristics.assignListLevels( editor, element );
			}

			// A dummy call to cache parsed list info inside of cke-list-* attributes.
			this.getListItemInfo( element );

			if ( !element.attributes[ &#39;cke-dissolved&#39; ] ) {
				// The symbol is usually the first text node descendant
				// of the element that doesn&#39;t start with a whitespace character;
				var symbol;

				element.forEach( function( element ) {
					// Sometimes there are custom markers represented as images.
					// They can be recognized by the distinctive alt attribute value.
					if ( !symbol &amp;&amp; element.name == &#39;img&#39; &amp;&amp;
						element.attributes[ &#39;cke-ignored&#39; ] &amp;&amp;
						element.attributes.alt == &#39;*&#39; ) {
						symbol = &#39;·&#39;;
						// Remove the &quot;symbol&quot; now, since it&#39;s the best opportunity to do so.
						element.remove();
					}
				}, CKEDITOR.NODE_ELEMENT );

				element.forEach( function( element ) {
					if ( !symbol &amp;&amp; !element.value.match( /^ / ) ) {
						symbol = element.value;
					}
				}, CKEDITOR.NODE_TEXT );

				// Without a symbol this isn&#39;t really a list item.
				if ( typeof symbol == &#39;undefined&#39; ) {
					return;
				}

				element.attributes[ &#39;cke-symbol&#39; ] = symbol.replace( /(?: |&amp;nbsp;).*$/, &#39;&#39; );

				List.removeSymbolText( element );
			}

			if ( element.attributes.style ) {
				// Hacky way to get rid of margin left.
				// @todo: we should gather all css cleanup here, and consider bidi. Eventually we might put a config variable to
				// to enable it.
				var styles = tools.parseCssText( element.attributes.style );

				if ( styles[ &#39;margin-left&#39; ] ) {
					delete styles[ &#39;margin-left&#39; ];
					element.attributes.style =  CKEDITOR.tools.writeCssText( styles );
				}
			}

			// Converting to a normal list item would implicitly wrap the element around an &lt;ul&gt;.
			element.name = &#39;cke:li&#39;;
		},

<span id='CKEDITOR-plugins-pastefromword-lists-method-convertToRealListItems'>		/**
</span>		 * Converts any fake list items contained within `root` into real `li` elements.
		 *
		 * @private
		 * @param {CKEDITOR.htmlParser.element} root
		 * @returns {CKEDITOR.htmlParser.element[]} An array of converted elements.
		 * @member CKEDITOR.plugins.pastefromword.lists
		 */
		convertToRealListItems: function( root ) {
			var listElements = [];
			// Select and clean up list elements.
			root.forEach( function( element ) {
				if ( element.name == &#39;cke:li&#39; ) {
					element.name = &#39;li&#39;;

					//List.removeSymbolText( element );

					listElements.push( element );
				}
			}, CKEDITOR.NODE_ELEMENT, false );

			return listElements;
		},

		removeSymbolText: function( element ) { // ...from a list element.
			var removed,
				symbol = element.attributes[ &#39;cke-symbol&#39; ];

			element.forEach( function( node ) {
				// Since symbol may contains special characters we use `indexOf` (instead of RegExp) which is sufficient (#877).
				if ( !removed &amp;&amp; node.value.indexOf( symbol ) &gt; -1 ) {

					node.value = node.value.replace( symbol, &#39;&#39; );

					if ( node.parent.getHtml().match( /^(\s|&amp;nbsp;)*$/ ) ) {
						removed = node.parent !== element ? node.parent : null;
					}
				}
			}, CKEDITOR.NODE_TEXT );

			removed &amp;&amp; removed.remove();
		},

		setListSymbol: function( list, symbol, level ) {
			level = level || 1;

			var style = tools.parseCssText( list.attributes.style );

			if ( list.name == &#39;ol&#39; ) {
				if ( list.attributes.type || style[ &#39;list-style-type&#39; ] ) return;

				var typeMap = {
					&#39;[ivx]&#39;: &#39;lower-roman&#39;,
					&#39;[IVX]&#39;: &#39;upper-roman&#39;,
					&#39;[a-z]&#39;: &#39;lower-alpha&#39;,
					&#39;[A-Z]&#39;: &#39;upper-alpha&#39;,
					&#39;\\d&#39;: &#39;decimal&#39;
				};

				for ( var type in typeMap ) {
					if ( List.getSubsectionSymbol( symbol ).match( new RegExp( type ) ) ) {
						style[ &#39;list-style-type&#39; ] = typeMap[ type ];
						break;
					}
				}

				list.attributes[ &#39;cke-list-style-type&#39; ] = style[ &#39;list-style-type&#39; ];
			} else {
				var symbolMap = {
					&#39;·&#39;: &#39;disc&#39;,
					&#39;o&#39;: &#39;circle&#39;,
					&#39;§&#39;: &#39;square&#39; // In Word this is a square.
				};

				if ( !style[ &#39;list-style-type&#39; ] &amp;&amp; symbolMap[ symbol ] ) {
					style[ &#39;list-style-type&#39; ] = symbolMap[ symbol ];
				}

			}

			List.setListSymbol.removeRedundancies( style, level );

			( list.attributes.style = CKEDITOR.tools.writeCssText( style ) ) || delete list.attributes.style;
		},

		setListStart: function( list ) {
			var symbols = [],
				offset = 0;

			for ( var i = 0; i &lt; list.children.length; i++ ) {
				symbols.push( list.children[ i ].attributes[ &#39;cke-symbol&#39; ] || &#39;&#39; );
			}

			// When a list starts with a sublist, use the next element as a start indicator.
			if ( !symbols[ 0 ] ) {
				offset++;
			}

			// Attribute set in setListSymbol()
			switch ( list.attributes[ &#39;cke-list-style-type&#39; ] ) {
				case &#39;lower-roman&#39;:
				case &#39;upper-roman&#39;:
					list.attributes.start = List.toArabic( List.getSubsectionSymbol( symbols[ offset ] ) ) - offset;
					break;
				case &#39;lower-alpha&#39;:
				case &#39;upper-alpha&#39;:
					list.attributes.start = List.getSubsectionSymbol( symbols[ offset ] ).replace( /\W/g, &#39;&#39; ).toLowerCase().charCodeAt( 0 ) - 96 - offset;
					break;
				case &#39;decimal&#39;:
					list.attributes.start = ( parseInt( List.getSubsectionSymbol( symbols[ offset ] ), 10 ) - offset ) || 1;
					break;
			}

			if ( list.attributes.start == &#39;1&#39; ) {
				delete list.attributes.start;
			}

			delete list.attributes[ &#39;cke-list-style-type&#39; ];
		},

		numbering: {
<span id='CKEDITOR-plugins-pastefromword-lists-numbering-method-toNumber'>			/**
</span>			 * Converts the list marker value into a decimal number.
			 *
			 *		 var toNumber = CKEDITOR.plugins.pastefromword.lists.numbering.toNumber;
			 *
			 *		 console.log( toNumber( &#39;XIV&#39;, &#39;upper-roman&#39; ) ); // Logs 14.
			 *		 console.log( toNumber( &#39;d&#39;, &#39;lower-alpha&#39; ) ); // Logs 4.
			 *		 console.log( toNumber( &#39;35&#39;, &#39;decimal&#39; ) ); // Logs 35.
			 *		 console.log( toNumber( &#39;404&#39;, &#39;foo&#39; ) ); // Logs 1.
			 *
			 * @param {String} marker
			 * @param {String} markerType Marker type according to CSS `list-style-type` values.
			 * @returns {Number}
			 * @member CKEDITOR.plugins.pastefromword.lists.numbering
			 */
			toNumber: function( marker, markerType ) {
				// Functions copied straight from old PFW implementation, no need to reinvent the wheel.
				function fromAlphabet( str ) {
					var alpahbets = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;;

					str = str.toUpperCase();
					var l = alpahbets.length,
						retVal = 1;
					for ( var x = 1; str.length &gt; 0; x *= l ) {
						retVal += alpahbets.indexOf( str.charAt( str.length - 1 ) ) * x;
						str = str.substr( 0, str.length - 1 );
					}
					return retVal;
				}

				function fromRoman( str ) {
					var romans = [
							[ 1000, &#39;M&#39; ],
							[ 900, &#39;CM&#39; ],
							[ 500, &#39;D&#39; ],
							[ 400, &#39;CD&#39; ],
							[ 100, &#39;C&#39; ],
							[ 90, &#39;XC&#39; ],
							[ 50, &#39;L&#39; ],
							[ 40, &#39;XL&#39; ],
							[ 10, &#39;X&#39; ],
							[ 9, &#39;IX&#39; ],
							[ 5, &#39;V&#39; ],
							[ 4, &#39;IV&#39; ],
							[ 1, &#39;I&#39; ]
						];

					str = str.toUpperCase();
					var l = romans.length,
						retVal = 0;
					for ( var i = 0; i &lt; l; ++i ) {
						for ( var j = romans[ i ], k = j[ 1 ].length; str.substr( 0, k ) == j[ 1 ]; str = str.substr( k ) )
							retVal += j[ 0 ];
					}
					return retVal;
				}

				if ( markerType == &#39;decimal&#39; ) {
					return Number( marker );
				} else if ( markerType == &#39;upper-roman&#39; || markerType == &#39;lower-roman&#39; ) {
					return fromRoman( marker.toUpperCase() );
				} else if ( markerType == &#39;lower-alpha&#39; || markerType == &#39;upper-alpha&#39; ) {
					return fromAlphabet( marker );
				} else {
					return 1;
				}
			},

<span id='CKEDITOR-plugins-pastefromword-lists-numbering-method-getStyle'>			/**
</span>			 * Returns a list style based on the Word marker content.
			 *
			 *		var getStyle = CKEDITOR.plugins.pastefromword.lists.numbering.getStyle;
			 *
			 *		console.log( getStyle( &#39;4&#39; ) ); // Logs: &quot;decimal&quot;
			 *		console.log( getStyle( &#39;b&#39; ) ); // Logs: &quot;lower-alpha&quot;
			 *		console.log( getStyle( &#39;P&#39; ) ); // Logs: &quot;upper-alpha&quot;
			 *		console.log( getStyle( &#39;i&#39; ) ); // Logs: &quot;lower-roman&quot;
			 *		console.log( getStyle( &#39;X&#39; ) ); // Logs: &quot;upper-roman&quot;
			 *
			 *
			 * **Implementation note:** Characters `c` and `d` are not converted to roman on purpose. It is 100 and 500 respectively, so
			 * you rarely go with a list up until this point, while it is common to start with `c` and `d` in alpha.
			 *
			 * @param {String} marker Marker content retained from Word, e.g. `1`, `7`, `XI`, `b`.
			 * @returns {String} Resolved marker type.
			 * @member CKEDITOR.plugins.pastefromword.lists.numbering
			 */
			getStyle: function( marker ) {
				var typeMap = {
						&#39;i&#39;: &#39;lower-roman&#39;,
						&#39;v&#39;: &#39;lower-roman&#39;,
						&#39;x&#39;: &#39;lower-roman&#39;,
						&#39;l&#39;: &#39;lower-roman&#39;,
						&#39;m&#39;: &#39;lower-roman&#39;,
						&#39;I&#39;: &#39;upper-roman&#39;,
						&#39;V&#39;: &#39;upper-roman&#39;,
						&#39;X&#39;: &#39;upper-roman&#39;,
						&#39;L&#39;: &#39;upper-roman&#39;,
						&#39;M&#39;: &#39;upper-roman&#39;
					},
					firstCharacter = marker.slice( 0, 1 ),
					type = typeMap[ firstCharacter ];

				if ( !type ) {
					type = &#39;decimal&#39;;

					if ( firstCharacter.match( /[a-z]/ ) ) {
						type = &#39;lower-alpha&#39;;
					}
					if ( firstCharacter.match( /[A-Z]/ ) ) {
						type = &#39;upper-alpha&#39;;
					}
				}

				return type;
			}
		},

		// Taking into account cases like &quot;1.1.2.&quot; etc. - get the last element.
		getSubsectionSymbol: function( symbol ) {
			return ( symbol.match( /([\da-zA-Z]+).?$/ ) || [ &#39;placeholder&#39;, &#39;1&#39; ] )[ 1 ];
		},

		setListDir: function( list ) {
			var dirs = { ltr: 0, rtl: 0 };

			list.forEach( function( child ) {
				if ( child.name == &#39;li&#39; ) {
					var dir = child.attributes.dir || child.attributes.DIR || &#39;&#39;;
					if ( dir.toLowerCase() == &#39;rtl&#39; ) {
						dirs.rtl++;
					} else {
						dirs.ltr++;
					}
				}
			}, CKEDITOR.ELEMENT_NODE );

			if ( dirs.rtl &gt; dirs.ltr ) {
				list.attributes.dir = &#39;rtl&#39;;
			}
		},

		createList: function( element ) {
			// &quot;o&quot; symbolizes a circle in unordered lists.
			if ( ( element.attributes[ &#39;cke-symbol&#39; ].match( /([\da-np-zA-NP-Z]).?/ ) || [] )[ 1 ] ) {
				return new CKEDITOR.htmlParser.element( &#39;ol&#39; );
			}
			return new CKEDITOR.htmlParser.element( &#39;ul&#39; );
		},

<span id='CKEDITOR-plugins-pastefromword-lists-method-createLists'>		/**
</span>		 * @private
		 * @param {CKEDITOR.htmlParser.element} root An element to be looked through for lists.
		 * @returns {CKEDITOR.htmlParser.element[]} An array of created list items.
		 * @member CKEDITOR.plugins.pastefromword.lists
		 */
		createLists: function( root ) {
			var element, level, i, j,
				listElements = List.convertToRealListItems( root );

			if ( listElements.length === 0 ) {
				return [];
			}

			// Chop data into continuous lists.
			var lists = List.groupLists( listElements );

			// Create nested list structures.
			for ( i = 0; i &lt; lists.length; i++ ) {
				var list = lists[ i ],
					firstLevel1Element = list[ 0 ];

				// To determine the type of the top-level list a level 1 element is needed.
				for ( j = 0; j &lt; list.length; j++ ) {
					if ( list[ j ].attributes[ &#39;cke-list-level&#39; ] == 1 ) {
						firstLevel1Element = list[ j ];
						break;
					}
				}

				var	containerStack = [ List.createList( firstLevel1Element ) ],
					// List wrapper (ol/ul).
					innermostContainer = containerStack[ 0 ],
					allContainers = [ containerStack[ 0 ] ];

				// Insert first known list item before the list wrapper.
				innermostContainer.insertBefore( list[ 0 ] );

				for ( j = 0; j &lt; list.length; j++ ) {
					element = list[ j ];

					level = element.attributes[ &#39;cke-list-level&#39; ];

					while ( level &gt; containerStack.length ) {
						var content = List.createList( element );

						var children = innermostContainer.children;
						if ( children.length &gt; 0 ) {
							children[ children.length - 1 ].add( content );
						} else {
							var container = new CKEDITOR.htmlParser.element( &#39;li&#39;, {
								style: &#39;list-style-type:none&#39;
							} );
							container.add( content );
							innermostContainer.add( container );
						}

						containerStack.push( content );
						allContainers.push( content );
						innermostContainer = content;

						if ( level == containerStack.length ) {
							List.setListSymbol( content, element.attributes[ &#39;cke-symbol&#39; ], level );
						}
					}

					while ( level &lt; containerStack.length ) {
						containerStack.pop();
						innermostContainer = containerStack[ containerStack.length - 1 ];

						if ( level == containerStack.length ) {
							List.setListSymbol( innermostContainer, element.attributes[ &#39;cke-symbol&#39; ], level );
						}
					}

					// For future reference this is where the list elements are actually put into the lists.
					element.remove();
					innermostContainer.add( element );
				}

				// Try to set the symbol for the root (level 1) list.
				var level1Symbol;
				if ( containerStack[ 0 ].children.length ) {
					level1Symbol = containerStack[ 0 ].children[ 0 ].attributes[ &#39;cke-symbol&#39; ];

					if ( !level1Symbol &amp;&amp; containerStack[ 0 ].children.length &gt; 1 ) {
						level1Symbol = containerStack[0].children[1].attributes[ &#39;cke-symbol&#39; ];
					}

					if ( level1Symbol ) {
						List.setListSymbol( containerStack[ 0 ], level1Symbol );
					}
				}

				// This can be done only after all the list elements are where they should be.
				for ( j = 0; j &lt; allContainers.length; j++ ) {
					List.setListStart( allContainers[ j ] );
				}

				// Last but not least apply li[start] if needed, also this needs to be done once ols are final.
				for ( j = 0; j &lt; list.length; j++ ) {
					this.determineListItemValue( list[ j ] );
				}
			}

			return listElements;
		},

<span id='CKEDITOR-plugins-pastefromword-lists-method-cleanup'>		/**
</span>		 * Final cleanup &amp;mdash; removes all `cke-*` helper attributes.
		 *
		 * @private
		 * @param {CKEDITOR.htmlParser.element[]} listElements
		 * @member CKEDITOR.plugins.pastefromword.lists
		 */
		cleanup: function( listElements ) {
			var tempAttributes = [
					&#39;cke-list-level&#39;,
					&#39;cke-symbol&#39;,
					&#39;cke-list-id&#39;,
					&#39;cke-indentation&#39;,
					&#39;cke-dissolved&#39;
				],
				i,
				j;

			for ( i = 0; i &lt; listElements.length; i++ ) {
				for ( j = 0; j &lt; tempAttributes.length; j++ ) {
					delete listElements[ i ].attributes[ tempAttributes[ j ] ];
				}
			}
		},

<span id='CKEDITOR-plugins-pastefromword-lists-method-determineListItemValue'>		/**
</span>		 * Tries to determine the `li[value]` attribute for a given list item. The `element` given must
		 * have a parent in order for this function to work properly.
		 *
		 * @private
		 * @param {CKEDITOR.htmlParser.element} element
		 * @member CKEDITOR.plugins.pastefromword.lists
		 */
		determineListItemValue: function( element ) {
			if ( element.parent.name !== &#39;ol&#39; ) {
				// li[value] make sense only for list items in ordered list.
				return;
			}

			var assumedValue = this.calculateValue(  element ),
				cleanSymbol = element.attributes[ &#39;cke-symbol&#39; ].match( /[a-z0-9]+/gi ),
				computedValue,
				listType;

			if ( cleanSymbol ) {
				// Note that we always want to use last match, just because of markers like &quot;1.1.4&quot; &quot;1.A.a.IV&quot; etc.
				cleanSymbol = cleanSymbol[ cleanSymbol.length - 1 ];

				// We can determine proper value only if we know what type of list is it.
				// So we need to check list wrapper if it has this information.
				listType = element.parent.attributes[ &#39;cke-list-style-type&#39; ] || this.numbering.getStyle( cleanSymbol );

				computedValue = this.numbering.toNumber( cleanSymbol, listType );

				if ( computedValue !== assumedValue ) {
					element.attributes.value = computedValue;
				}
			}
		},

<span id='CKEDITOR-plugins-pastefromword-lists-method-calculateValue'>		/**
</span>		 * Calculates the value for a given `&lt;li&gt;` element based on its precedent list items (e.g. the `value`
		 * attribute). It could also look at the list parent (`&lt;ol&gt;`) at its start attribute.
		 *
		 * @private
		 * @param {CKEDITOR.htmlParser.element} element The `&lt;li&gt;` element.
		 * @returns {Number}
		 * @member CKEDITOR.plugins.pastefromword.lists
		 */
		calculateValue: function( element ) {
			if ( !element.parent ) {
				return 1;
			}

			var list = element.parent,
				elementIndex = element.getIndex(),
				valueFound = null,
				// Index of the element with value attribute.
				valueElementIndex,
				curElement,
				i;

			// Look for any preceding li[value].
			for	( i = elementIndex; i &gt;= 0 &amp;&amp; valueFound === null; i-- ) {
				curElement = list.children[ i ];

				if ( curElement.attributes &amp;&amp; curElement.attributes.value !== undefined ) {
					valueElementIndex = i;
					valueFound = parseInt( curElement.attributes.value, 10 );
				}
			}

			// Still if no li[value] was found, we&#39;ll check the list.
			if ( valueFound === null ) {
				valueFound = list.attributes.start !== undefined ? parseInt( list.attributes.start, 10 ) : 1;
				valueElementIndex = 0;
			}

			return valueFound + ( elementIndex - valueElementIndex );
		},

<span id='CKEDITOR-plugins-pastefromword-lists-method-dissolveList'>		/**
</span>		 * @private
		 * @param {CKEDITOR.htmlParser.element} element
		 * @member CKEDITOR.plugins.pastefromword.lists
		 */
		dissolveList: function( element ) {
			var nameIs = function( name ) {
					return function( element ) {
						return element.name == name;
					};
				},
				isList = function( element ) {
					return nameIs( &#39;ul&#39; )( element ) || nameIs( &#39;ol&#39; )( element );
				},
				arrayTools = CKEDITOR.tools.array,
				elements = [],
				children,
				i;

			element.forEach( function( child ) {
				elements.push( child );
			}, CKEDITOR.NODE_ELEMENT, false );

			var items = arrayTools.filter( elements, nameIs( &#39;li&#39; ) ),
				lists = arrayTools.filter( elements, isList );

			arrayTools.forEach( lists, function( list ) {
				var type = list.attributes.type,
					start = parseInt( list.attributes.start, 10 ) || 1,
					level = countParents( isList, list ) + 1;

				if ( !type ) {
					var style = tools.parseCssText( list.attributes.style );
					type = style[ &#39;list-style-type&#39; ];
				}

				arrayTools.forEach( arrayTools.filter( list.children, nameIs( &#39;li&#39; ) ), function( child, index ) {
					var symbol;

					switch ( type ) {
						case &#39;disc&#39;:
							symbol = &#39;·&#39;;
							break;
						case &#39;circle&#39;:
							symbol = &#39;o&#39;;
							break;
						case &#39;square&#39;:
							symbol = &#39;§&#39;;
							break;
						case &#39;1&#39;:
						case &#39;decimal&#39;:
							symbol = ( start + index ) + &#39;.&#39;;
							break;
						case &#39;a&#39;:
						case &#39;lower-alpha&#39;:
							symbol = String.fromCharCode( &#39;a&#39;.charCodeAt( 0 ) + start - 1 + index ) + &#39;.&#39;;
							break;
						case &#39;A&#39;:
						case &#39;upper-alpha&#39;:
							symbol = String.fromCharCode( &#39;A&#39;.charCodeAt( 0 ) + start - 1 + index ) + &#39;.&#39;;
							break;
						case &#39;i&#39;:
						case &#39;lower-roman&#39;:
							symbol = toRoman( start + index ) + &#39;.&#39;;
							break;
						case &#39;I&#39;:
						case &#39;upper-roman&#39;:
							symbol = toRoman( start + index ).toUpperCase() + &#39;.&#39;;
							break;
						default:
							symbol = list.name == &#39;ul&#39; ? &#39;·&#39; : ( start + index ) + &#39;.&#39;;
					}

					child.attributes[ &#39;cke-symbol&#39; ] = symbol;
					child.attributes[ &#39;cke-list-level&#39; ] = level;
				} );
			} );

			children = arrayTools.reduce( items, function( acc, listElement ) {
				var child = listElement.children[ 0 ];

				if ( child &amp;&amp; child.name &amp;&amp; child.attributes.style &amp;&amp; child.attributes.style.match( /mso-list:/i ) ) {
					Style.pushStylesLower( listElement, {
						&#39;list-style-type&#39;: true,
						&#39;display&#39;: true
					} );

					var childStyle = tools.parseCssText( child.attributes.style, true );

					Style.setStyle( listElement, &#39;mso-list&#39;, childStyle[ &#39;mso-list&#39; ], true );
					Style.setStyle( child, &#39;mso-list&#39;, &#39;&#39; );
					// mso-list takes precedence in determining the level.
					delete listElement[ &#39;cke-list-level&#39; ];

					// If this style has a value it&#39;s usually &quot;none&quot;. This marks such list elements for deletion.
					var styleName = childStyle.display ? &#39;display&#39; : childStyle.DISPLAY ? &#39;DISPLAY&#39; : &#39;&#39;;
					if ( styleName ) {
						Style.setStyle( listElement, &#39;display&#39;, childStyle[ styleName ], true );
					}
				}

				// Don&#39;t include elements put there only to contain another list.
				if ( listElement.children.length === 1 &amp;&amp; isList( listElement.children[ 0 ] ) ) {
					return acc;
				}

				listElement.name = &#39;p&#39;;
				listElement.attributes[ &#39;cke-dissolved&#39; ] = true;
				acc.push( listElement );

				return acc;
			}, [] );

			for ( i = children.length - 1; i &gt;= 0; i-- ) {
				children[ i ].insertAfter( element );
			}
			for ( i = lists.length - 1; i &gt;= 0; i-- ) {
				delete lists[ i ].name;
			}

			function toRoman( number ) {
				if ( number &gt;= 50 ) return &#39;l&#39; + toRoman( number - 50 );
				if ( number &gt;= 40 ) return &#39;xl&#39; + toRoman( number - 40 );
				if ( number &gt;= 10 ) return &#39;x&#39; + toRoman( number - 10 );
				if ( number == 9 ) return &#39;ix&#39;;
				if ( number &gt;= 5 ) return &#39;v&#39; + toRoman( number - 5 );
				if ( number == 4 ) return &#39;iv&#39;;
				if ( number &gt;= 1 ) return &#39;i&#39; + toRoman( number - 1 );
				return &#39;&#39;;
			}

			function countParents( condition, element ) {
				return count( element, 0 );

				function count( parent, number ) {
					if ( !parent || !parent.parent ) {
						return number;
					}

					if ( condition( parent.parent ) ) {
						return count( parent.parent, number + 1 );
					} else {
						return count( parent.parent, number );
					}
				}
			}

		},

		groupLists: function( listElements ) {
			// Chop data into continuous lists.
			var i, element,
				lists = [ [ listElements[ 0 ] ] ],
				lastList = lists[ 0 ];

			element = listElements[ 0 ];
			element.attributes[ &#39;cke-indentation&#39; ] = element.attributes[ &#39;cke-indentation&#39; ] || List.getElementIndentation( element );

			for ( i = 1; i &lt; listElements.length; i++ ) {
				element = listElements[ i ];
				var previous = listElements[ i - 1 ];

				element.attributes[ &#39;cke-indentation&#39; ] = element.attributes[ &#39;cke-indentation&#39; ] || List.getElementIndentation( element );

				if ( element.previous !== previous ) {
					List.chopDiscontinuousLists( lastList, lists );
					lists.push( lastList = [] );
				}

				lastList.push( element );
			}

			List.chopDiscontinuousLists( lastList, lists );

			return lists;
		},

<span id='CKEDITOR-plugins-pastefromword-lists-method-chopDiscontinuousLists'>		/**
</span>		 * Converts a single, flat list items array into an array with a hierarchy of items.
		 *
		 * As the list gets chopped, it will be forced to render as a separate list, even if it has a deeper nesting level.
		 * For example, for level 3 it will create a structure like `ol &gt; li &gt; ol &gt; li &gt; ol &gt; li`.
		 *
		 * Note that list items within a single list but with different levels that did not get chopped
		 * will still be rendered as a list tree later.
		 *
		 * @private
		 * @param {CKEDITOR.htmlParser.element[]} list An array containing list items.
		 * @param {CKEDITOR.htmlParser.element[]} lists All the lists in the pasted content represented by an array of arrays
		 * of list items. Modified by this method.
		 * @member CKEDITOR.plugins.pastefromword.lists
		 */
		chopDiscontinuousLists: function( list, lists ) {
			var levelSymbols = {};
			var choppedLists = [ [] ],
				lastListInfo;

			for ( var i = 0; i &lt; list.length; i++ ) {
				var lastSymbol = levelSymbols[ list[ i ].attributes[ &#39;cke-list-level&#39; ] ],
					currentListInfo = this.getListItemInfo( list[ i ] ),
					currentSymbol,
					forceType;

				if ( lastSymbol ) {
					// An &quot;h&quot; before an &quot;i&quot;.
					forceType = lastSymbol.type.match( /alpha/ ) &amp;&amp; lastSymbol.index == 7 ? &#39;alpha&#39; : forceType;
					// An &quot;n&quot; before an &quot;o&quot;.
					forceType = list[ i ].attributes[ &#39;cke-symbol&#39; ] == &#39;o&#39; &amp;&amp; lastSymbol.index == 14 ? &#39;alpha&#39; : forceType;

					currentSymbol = List.getSymbolInfo( list[ i ].attributes[ &#39;cke-symbol&#39; ], forceType );
					currentListInfo = this.getListItemInfo( list[ i ] );

					// Based on current and last index we&#39;ll decide if we want to chop list.
					if (
						// If the last list was a different list type then chop it!
						lastSymbol.type != currentSymbol.type ||
						// If those are logically different lists, and current list is not a continuation (https://dev.ckeditor.com/ticket/7918):
						( lastListInfo &amp;&amp; currentListInfo.id != lastListInfo.id &amp;&amp; !this.isAListContinuation( list[ i ] ) ) ) {
						choppedLists.push( [] );
					}
				} else {
					currentSymbol = List.getSymbolInfo( list[ i ].attributes[ &#39;cke-symbol&#39; ] );
				}

				// Reset all higher levels
				for ( var j = parseInt( list[ i ].attributes[ &#39;cke-list-level&#39; ], 10 ) + 1; j &lt; 20; j++ ) {
					if ( levelSymbols[ j ] ) {
						delete levelSymbols[ j ];
					}
				}

				levelSymbols[ list[ i ].attributes[ &#39;cke-list-level&#39; ] ] = currentSymbol;
				choppedLists[ choppedLists.length - 1 ].push( list[ i ] );

				lastListInfo = currentListInfo;
			}

			[].splice.apply( lists, [].concat( [ tools.indexOf( lists, list ), 1 ], choppedLists ) );
		},

<span id='CKEDITOR-plugins-pastefromword-lists-method-isAListContinuation'>		/**
</span>		 * Checks if this list is a direct continuation of a list interrupted by a list with a different ID,
		 * with a different level. So if you look at a following list:
		 *
		 * * list1 level1
		 * * list1 level1
		 *		* list2 level2
		 *		* list2 level2
		 * * list1 level1
		 *
		 * It would return `true` &amp;mdash; meaning it is a continuation, and should not be chopped. However, if any paragraph or
		 * anything else appears in between, it should be broken into different lists.
		 *
		 * You can see fixtures from issue https://dev.ckeditor.com/ticket/7918 as an example.
		 *
		 * @private
		 * @param {CKEDITOR.htmlParser.element} listElement The list to be checked.
		 * @returns {Boolean}
		 * @member CKEDITOR.plugins.pastefromword.lists
		 */
		isAListContinuation: function( listElement ) {
			var prev = listElement;

			do {
				prev = prev.previous;

				if ( prev &amp;&amp; prev.type === CKEDITOR.NODE_ELEMENT ) {
					if ( prev.attributes[ &#39;cke-list-level&#39; ] === undefined ) {
						// Not a list, so looks like an interrupted list.
						return false;
					}

					if ( prev.attributes[ &#39;cke-list-level&#39; ] === listElement.attributes[ &#39;cke-list-level&#39; ] ) {
						// Same level, so we want to check if this is a continuation.
						return prev.attributes[ &#39;cke-list-id&#39; ] === listElement.attributes[ &#39;cke-list-id&#39; ];
					}
				}

			} while ( prev );

			return false;
		},

		getElementIndentation: function( element ) {
			var style = tools.parseCssText( element.attributes.style );

			if ( style.margin || style.MARGIN ) {
				style.margin = style.margin || style.MARGIN;
				var fakeElement = {
					styles: {
						margin: style.margin
					}
				};
				CKEDITOR.filter.transformationsTools.splitMarginShorthand( fakeElement );
				style[ &#39;margin-left&#39; ] = fakeElement.styles[ &#39;margin-left&#39; ];
			}

			return parseInt( tools.convertToPx( style[ &#39;margin-left&#39; ] || &#39;0px&#39; ), 10 );
		},

		// Source: http://stackoverflow.com/a/17534350/3698944
		toArabic: function( symbol ) {
			if ( !symbol.match( /[ivxl]/i ) ) return 0;
			if ( symbol.match( /^l/i ) ) return 50 + List.toArabic( symbol.slice( 1 ) );
			if ( symbol.match( /^lx/i ) ) return 40 + List.toArabic( symbol.slice( 1 ) );
			if ( symbol.match( /^x/i ) ) return 10 + List.toArabic( symbol.slice( 1 ) );
			if ( symbol.match( /^ix/i ) ) return 9 + List.toArabic( symbol.slice( 2 ) );
			if ( symbol.match( /^v/i ) ) return 5 + List.toArabic( symbol.slice( 1 ) );
			if ( symbol.match( /^iv/i ) ) return 4 + List.toArabic( symbol.slice( 2 ) );
			if ( symbol.match( /^i/i ) ) return 1 + List.toArabic( symbol.slice( 1 ) );
			// Ignore other characters.
			return List.toArabic( symbol.slice( 1 ) );
		},

<span id='CKEDITOR-plugins-pastefromword-lists-method-getSymbolInfo'>		/**
</span>		 * Returns an object describing the given `symbol`.
		 *
		 * @private
		 * @param {String} symbol
		 * @param {String} type
		 * @returns {Object} ret
		 * @returns {Number} ret.index Identified numbering value
		 * @returns {String} ret.type One of `decimal`, `disc`, `circle`, `square`, `roman`, `alpha`.
		 * @member CKEDITOR.plugins.pastefromword.lists
		 */
		getSymbolInfo: function( symbol, type ) {
			var symbolCase = symbol.toUpperCase() == symbol ? &#39;upper-&#39; : &#39;lower-&#39;,
				symbolMap = {
					&#39;·&#39;: [ &#39;disc&#39;, -1 ],
					&#39;o&#39;: [ &#39;circle&#39;, -2 ],
					&#39;§&#39;: [ &#39;square&#39;, -3 ]
				};

			if ( symbol in symbolMap || ( type &amp;&amp; type.match( /(disc|circle|square)/ ) ) ) {
				return {
					index: symbolMap[ symbol ][ 1 ],
					type: symbolMap[ symbol ][ 0 ]
				};
			}

			if ( symbol.match( /\d/ ) ) {
				return {
					index: symbol ? parseInt( List.getSubsectionSymbol( symbol ) , 10 ) : 0,
					type: &#39;decimal&#39;
				};
			}

			symbol = symbol.replace( /\W/g, &#39;&#39; ).toLowerCase();

			if ( ( !type &amp;&amp; symbol.match( /[ivxl]+/i ) ) || ( type &amp;&amp; type != &#39;alpha&#39; ) || type == &#39;roman&#39; ) {
				return {
					index: List.toArabic( symbol ),
					type: symbolCase + &#39;roman&#39;
				};
			}

			if ( symbol.match( /[a-z]/i ) ) {
				return {
					index: symbol.charCodeAt( 0 ) - 97,
					type: symbolCase + &#39;alpha&#39;
				};
			}

			return {
				index: -1,
				type: &#39;disc&#39;
			};
		},

<span id='CKEDITOR-plugins-pastefromword-lists-method-getListItemInfo'>		/**
</span>		 * Returns Word-generated information about the given list item, mainly by parsing the `mso-list`
		 * CSS property.
		 *
		 * Note: Paragraphs with `mso-list` are also counted as list items because Word serves
		 * list items as paragraphs.
		 *
		 * @private
		 * @param {CKEDITOR.htmlParser.element} list
		 * @returns ret
		 * @returns {String} ret.id List ID. Usually it is a decimal string.
		 * @returns {String} ret.level List nesting level, `0` means it is the outermost list. Usually it is
		 * a decimal string.
		 * @member CKEDITOR.plugins.pastefromword.lists
		 */
		getListItemInfo: function( list ) {
			if ( list.attributes[ &#39;cke-list-id&#39; ] !== undefined ) {
				// List was already resolved.
				return {
					id: list.attributes[ &#39;cke-list-id&#39; ],
					level: list.attributes[ &#39;cke-list-level&#39; ]
				};
			}

			var propValue = tools.parseCssText( list.attributes.style )[ &#39;mso-list&#39; ],
				ret = {
					id: &#39;0&#39;,
					level: &#39;1&#39;
				};

			if ( propValue ) {
				// Add one whitespace so it&#39;s easier to match values assuming that all of these are separated with \s.
				propValue += &#39; &#39;;

				ret.level = propValue.match( /level(.+?)\s+/ )[ 1 ];
				ret.id = propValue.match( /l(\d+?)\s+/ )[ 1 ];
			}

			// Store values. List level will be reused if present to prevent regressions.
			list.attributes[ &#39;cke-list-level&#39; ] = list.attributes[ &#39;cke-list-level&#39; ] !== undefined ? list.attributes[ &#39;cke-list-level&#39; ] : ret.level;
			list.attributes[ &#39;cke-list-id&#39; ] = ret.id;

			return ret;
		}
	};
	List = CKEDITOR.plugins.pastefromword.lists;

<span id='CKEDITOR-plugins-pastefromword-property-images'>	/**
</span>	 * Namespace containing a set of image helper methods.
	 *
	 * @private
	 * @since 4.8.0
	 * @member CKEDITOR.plugins.pastefromword
	 */
	CKEDITOR.plugins.pastefromword.images = {
<span id='CKEDITOR-plugins-pastefromword-images-method-extractFromRtf'>		/**
</span>		 * Method parses RTF content to find embedded images. Please be aware that this method should only return `png` and `jpeg` images.
		 *
		 * @private
		 * @since 4.8.0
		 * @param {String} rtfContent RTF content to be checked for images.
		 * @returns {Object[]} An array of images found in the `rtfContent`.
		 * @returns {String} return.hex Hexadecimal string of an image embedded in `rtfContent`.
		 * @returns {String} return.type String represent type of image, allowed values: &#39;image/png&#39;, &#39;image/jpeg&#39;.
		 * @member CKEDITOR.plugins.pastefromword.images
		 */
		extractFromRtf: function( rtfContent ) {
			var ret = [],
				rePictureHeader = /\{\\pict[\s\S]+?\\bliptag\-?\d+(\\blipupi\-?\d+)?(\{\\\*\\blipuid\s?[\da-fA-F]+)?[\s\}]*?/,
				rePicture = new RegExp( &#39;(?:(&#39; + rePictureHeader.source + &#39;))([\\da-fA-F\\s]+)\\}&#39;, &#39;g&#39; ),
				wholeImages,
				imageType;

			wholeImages = rtfContent.match( rePicture );
			if ( !wholeImages ) {
				return ret;
			}

			for ( var i = 0; i &lt; wholeImages.length; i++ ) {
				if ( rePictureHeader.test( wholeImages[ i ] ) ) {
					if ( wholeImages[ i ].indexOf( &#39;\\pngblip&#39; ) !== -1 ) {
						imageType = &#39;image/png&#39;;
					} else if ( wholeImages[ i ].indexOf( &#39;\\jpegblip&#39; ) !== -1 ) {
						imageType = &#39;image/jpeg&#39;;
					} else {
						continue;
					}

					ret.push( {
						hex: imageType ? wholeImages[ i ].replace( rePictureHeader, &#39;&#39; ).replace( /[^\da-fA-F]/g, &#39;&#39; ) : null,
						type: imageType
					} );
				}
			}

			return ret;
		},

<span id='CKEDITOR-plugins-pastefromword-images-method-extractTagsFromHtml'>		/**
</span>		 * Method extracts array of src attributes in img tags from given HTML. Img tags belonging to VML shapes are removed.
		 *
		 *		CKEDITOR.plugins.pastefromword.images.extractTagsFromHtml( html );
		 *		// Returns: [ &#39;http://example-picture.com/random.png&#39;, &#39;http://example-picture.com/another.png&#39; ]
		 *
		 * @private
		 * @param {String} html String represent HTML code.
		 * @returns {String[]} Array of strings represent src attribute of img tags found in `html`.
		 * @member CKEDITOR.plugins.pastefromword.images
		 */
		extractTagsFromHtml: function( html ) {
			var regexp = /&lt;img[^&gt;]+src=&quot;([^&quot;]+)[^&gt;]+/g,
				ret = [],
				item;

			while ( item = regexp.exec( html ) ) {
				ret.push( item[ 1 ] );
			}

			return ret;
		}
	};

<span id='CKEDITOR-plugins-pastefromword-property-heuristics'>	/**
</span>	 * Namespace containing methods used to process the pasted content using heuristics.
	 *
	 * @private
	 * @since 4.6.2
	 * @member CKEDITOR.plugins.pastefromword
	*/
	CKEDITOR.plugins.pastefromword.heuristics = {
<span id='CKEDITOR-plugins-pastefromword-heuristics-method-isEdgeListItem'>		/**
</span>		 * Decides if an `item` looks like a list item in Microsoft Edge.
		 *
		 * Note: It will return `false` when run in a browser other than Microsoft Edge, despite the configuration.
		 *
		 * @param {CKEDITOR.editor} editor
		 * @param {CKEDITOR.htmlParser.element} item
		 * @returns {Boolean}
		 * @member CKEDITOR.plugins.pastefromword.heuristics
		 * @private
		 */
		isEdgeListItem: function( editor, item ) {
			if ( !CKEDITOR.env.edge || !editor.config.pasteFromWord_heuristicsEdgeList ) {
				return false;
			}

			var innerText = &#39;&#39;;

			// Edge doesn&#39;t provide any list-specific markup, so the only way to guess if it&#39;s a list is to check the text structure.
			item.forEach &amp;&amp; item.forEach( function( text ) {
				innerText += text.value;
			}, CKEDITOR.NODE_TEXT );

			if ( innerText.match( /^(?: |&amp;nbsp;)*\(?[a-zA-Z0-9]+?[\.\)](?: |&amp;nbsp;){2,}/ ) ) {
				return true;
			}

			return Heuristics.isDegenerateListItem( editor, item );
		},

<span id='CKEDITOR-plugins-pastefromword-heuristics-method-cleanupEdgeListItem'>		/**
</span>		 * Cleans up a given list `item`. It is needed to remove Edge pre-marker indentation, since Edge pastes
		 * list items as plain paragraphs with multiple `&amp;nbsp;`s before the list marker.
		 *
		 * @since 4.7.0
		 * @param {CKEDITOR.htmlParser.element} item The pre-processed list-like item, like a paragraph.
		 * @member CKEDITOR.plugins.pastefromword.heuristics
		 * @private
		 */
		cleanupEdgeListItem: function( item ) {
			var textOccurred = false;

			item.forEach( function( node ) {
				if ( !textOccurred ) {
					node.value = node.value.replace( /^(?:&amp;nbsp;|[\s])+/, &#39;&#39; );

					// If there&#39;s any remaining text beside nbsp it means that we can stop filtering.
					if ( node.value.length ) {
						textOccurred = true;
					}
				}
			}, CKEDITOR.NODE_TEXT );
		},

<span id='CKEDITOR-plugins-pastefromword-heuristics-method-isDegenerateListItem'>		/**
</span>		 * Checks whether an element is a degenerate list item.
		 *
		 * Degenerate list items are elements that have some styles specific to list items,
		 * but lack the ones that could be used to determine their features (like list level etc.).
		 *
		 * @param {CKEDITOR.editor} editor
		 * @param {CKEDITOR.htmlParser.element} item
		 * @returns {Boolean}
		 * @member CKEDITOR.plugins.pastefromword.heuristics
		 * @private
		 * */
		isDegenerateListItem: function( editor, item ) {
			return !!item.attributes[ &#39;cke-list-level&#39; ] || ( item.attributes.style &amp;&amp; !item.attributes.style.match( /mso\-list/ ) &amp;&amp; !!item.find( function( child ) {
					// In rare cases there&#39;s no indication that a heading is a list item other than
					// the fact that it has a child element containing only a list symbol.
					if ( child.type == CKEDITOR.NODE_ELEMENT &amp;&amp; item.name.match( /h\d/i ) &amp;&amp;
						child.getHtml().match( /^[a-zA-Z0-9]+?[\.\)]$/ ) ) {
						return true;
					}

					var css = tools.parseCssText( child.attributes &amp;&amp; child.attributes.style, true );

					if ( !css ) {
						return false;
					}
					var fontSize = css.font || css[&#39;font-size&#39;] || &#39;&#39;,
						fontFamily = css[ &#39;font-family&#39; ] || &#39;&#39;;

					return ( fontSize.match( /7pt/i ) &amp;&amp; !!child.previous ) ||
						fontFamily.match( /symbol/i );
				}, true ).length );
		},

<span id='CKEDITOR-plugins-pastefromword-heuristics-method-assignListLevels'>		/**
</span>		 * Assigns list levels to the `item` and all directly subsequent nodes for which {@link #isEdgeListItem} returns `true`.
		 *
		 * The algorithm determines list item level based on the lowest common non-zero difference in indentation
		 * of two or more subsequent list-like elements.
		 *
		 * @param {CKEDITOR.editor} editor
		 * @param {CKEDITOR.htmlParser.element} item The first item of the list.
		 * @returns {Object/null} `null` if list levels were already applied, or an object used to verify results in tests.
		 * @returns {Number[]} return.indents
		 * @returns {Number[]} return.levels
		 * @returns {Number[]} return.diffs
		 * @member CKEDITOR.plugins.pastefromword.heuristics
		 * @private
		 */
		assignListLevels: function( editor, item ) {
			// If levels were already calculated, it means that this function was called for preceeding element. There&#39;s
			// no need to do this heavy work.
			if ( item.attributes &amp;&amp; item.attributes[ &#39;cke-list-level&#39; ] !== undefined ) {
				return;
			}

			var indents = [ List.getElementIndentation( item ) ],
				items = [ item ],
				levels = [],
				array = CKEDITOR.tools.array,
				map = array.map;

			while ( item.next &amp;&amp; item.next.attributes &amp;&amp; !item.next.attributes[ &#39;cke-list-level&#39; ] &amp;&amp; Heuristics.isDegenerateListItem( editor, item.next ) ) {
				item = item.next;
				indents.push( List.getElementIndentation( item ) );
				items.push( item );
			}

			// An array with indentation difference between n and n-1 list item. It&#39;s 0 for the first one.
			var indentationDiffs = map( indents, function( curIndent, i  ) {
					return i === 0 ? 0 : curIndent - indents[ i - 1 ];
				} ),
				// Guess indentation step, but it must not be equal to 0.
				indentationPerLevel = this.guessIndentationStep( array.filter( indents, function( val ) {
					return val !== 0;
				} ) );

			// Here&#39;s the tricky part, we need to magically figure out what is the indentation difference between list level.
			levels = map( indents, function( val ) {
				// Make sure that the level is a full number.
				return Math.round( val / indentationPerLevel );
			} );

			// Level can not be equal to 0, in case if it happens bump all the levels by 1,
			if ( array.indexOf( levels, 0 ) !== -1 ) {
				levels = map( levels, function( val ) {
					return val + 1;
				} );
			}

			// Assign levels to a proper place.
			array.forEach( items, function( curItem, index ) {
				curItem.attributes[ &#39;cke-list-level&#39; ] = levels[ index ];
			} );

			return {
				indents: indents,
				levels: levels,
				diffs: indentationDiffs
			};
		},

<span id='CKEDITOR-plugins-pastefromword-heuristics-method-guessIndentationStep'>		/**
</span>		 * Given an array of list indentations, this method tries to guess what the indentation difference per list level is.
		 * E.g. assuming that you have something like:
		 *
		 *		* foo (indentation 30px)
		 *				* bar (indentation 90px)
		 *				* baz (indentation 90px)
		 *					* baz (indentation 115px)
		 *			* baz (indentation 60px)
		 *
		 * The method will return `30`.
		 *
		 * @param {Number[]} indentations An array of indentation sizes.
		 * @returns {Number/null} A number or `null` if empty `indentations` was given.
		 * @member CKEDITOR.plugins.pastefromword.heuristics
		 * @private
		 */
		guessIndentationStep: function( indentations ) {
			return indentations.length ? Math.min.apply( null, indentations ) : null;
		},

<span id='CKEDITOR-plugins-pastefromword-heuristics-method-correctLevelShift'>		/**
</span>		 * Shifts lists that were deformed during pasting one level down
		 * so that the list structure matches the content copied from Word.
		 *
		 * @param {CKEDITOR.htmlParser.element} element
		 * @member CKEDITOR.plugins.pastefromword.heuristics
		 * @private
		 * */
		correctLevelShift: function( element ) {
			var isShiftedList = function( list ) {
				return list.children &amp;&amp; list.children.length == 1 &amp;&amp; Heuristics.isShifted( list.children[ 0 ] );
			};

			if ( this.isShifted( element ) ) {
				var lists = CKEDITOR.tools.array.filter( element.children, function( child ) {
					return ( child.name == &#39;ul&#39; || child.name == &#39;ol&#39; );
				} );

				var listChildren = CKEDITOR.tools.array.reduce( lists, function( acc, list ) {
					var preceding = isShiftedList( list ) ? [ list ] : list.children;
					return preceding.concat( acc );
				}, [] );

				CKEDITOR.tools.array.forEach( lists, function( list ) {
					list.remove();
				} );

				CKEDITOR.tools.array.forEach( listChildren, function( child ) {
					// `Add` method without index always append child at the end (#796).
					element.add( child );
				} );

				delete element.name;
			}
		},

<span id='CKEDITOR-plugins-pastefromword-heuristics-method-isShifted'>		/**
</span>		 * Determines if the list is malformed in a manner that its items
		 * are one level deeper than they should be.
		 *
		 * @param {CKEDITOR.htmlParser.element} element
		 * @returns {Boolean}
		 * @member CKEDITOR.plugins.pastefromword.heuristics
		 * @private
		 */
		isShifted: function( element ) {
			if ( element.name !== &#39;li&#39; ) {
				return false;
			}

			return CKEDITOR.tools.array.filter( element.children, function( child ) {
				if ( child.name ) {
					if ( child.name == &#39;ul&#39; || child.name == &#39;ol&#39; ) {
						return false;
					}

					if ( child.name == &#39;p&#39; &amp;&amp; child.children.length === 0 ) {
						return false;
					}
				}
				return true;
			} ).length === 0;
		}
	};

	Heuristics = CKEDITOR.plugins.pastefromword.heuristics;

	// Expose this function since it&#39;s useful in other places.
	List.setListSymbol.removeRedundancies = function( style, level ) {
		// &#39;disc&#39; and &#39;decimal&#39; are the default styles in some cases - remove redundancy.
		if ( ( level === 1 &amp;&amp; style[ &#39;list-style-type&#39; ] === &#39;disc&#39; ) || style[ &#39;list-style-type&#39; ] === &#39;decimal&#39; ) {
			delete style[ &#39;list-style-type&#39; ];
		}
	};

	function falseIfEmpty( value ) {
		if ( value === &#39;&#39; ) {
			return false;
		}
		return value;
	}

	// Used when filtering attributes - returning false deletes the attribute.
	function remove() {
		return false;
	}

	// Same as createStyleStack, but instead of styles - stack attributes.
	function createAttributeStack( element, filter ) {
		var i,
			children = [];

		element.filterChildren( filter );

		// Store element&#39;s children somewhere else.
		for ( i = element.children.length - 1; i &gt;= 0; i-- ) {
			children.unshift( element.children[ i ] );
			element.children[ i ].remove();
		}

		// Create a stack of spans with each containing one style.
		var attributes = element.attributes,
			innermostElement = element,
			topmost = true;

		for ( var attribute in attributes ) {

			if ( topmost ) {
				topmost = false;
				continue;
			}

			var newElement = new CKEDITOR.htmlParser.element( element.name );

			newElement.attributes[ attribute ] = attributes[ attribute ];

			innermostElement.add( newElement );
			innermostElement = newElement;

			delete attributes[ attribute ];
		}

		// Add the stored children to the innermost span.
		for ( i = 0; i &lt; children.length; i++ ) {
			innermostElement.add( children[ i ] );
		}
	}

	CKEDITOR.plugins.pastefromword.createAttributeStack = createAttributeStack;

<span id='CKEDITOR-plugins-pastefromword-lists-property-numbering'>	/**
</span>	 * Numbering helper.
	 *
	 * @property {CKEDITOR.plugins.pastefromword.lists.numbering} numbering
	 * @member CKEDITOR.plugins.pastefromword.lists
	 */

<span id='CKEDITOR-config-cfg-pasteFromWordRemoveFontStyles'>	/**
</span>	 * Whether to ignore all font-related formatting styles, including:
	 *
	 * * font size;
	 * * font family;
	 * * font foreground and background color.
	 *
	 *		config.pasteFromWordRemoveFontStyles = true;
	 *
	 * **Important note:** Prior to version 4.6.0 this configuration option defaulted to `true`.
	 *
	 * @deprecated 4.6.0 Either configure proper [Advanced Content Filter](#!/guide/dev_advanced_content_filter) for the editor
	 * or use the {@link CKEDITOR.editor#afterPasteFromWord} event.
	 * @since 3.1
	 * @cfg {Boolean} [pasteFromWordRemoveFontStyles=false]
	 * @member CKEDITOR.config
	 */

<span id='CKEDITOR-config-cfg-pasteFromWordNumberedHeadingToList'>	/**
</span>	 * Whether to transform Microsoft Word outline numbered headings into lists.
	 *
	 *		config.pasteFromWordNumberedHeadingToList = true;
	 *
	 * @removed 4.6.0
	 * @since 3.1
	 * @cfg {Boolean} [pasteFromWordNumberedHeadingToList=false]
	 * @member CKEDITOR.config
	 */

<span id='CKEDITOR-config-cfg-pasteFromWordRemoveStyles'>	/**
</span>	 * Whether to remove element styles that cannot be managed with the editor. Note
	 * that this option does not handle font-specific styles, which depend on the
	 * {@link #pasteFromWordRemoveFontStyles} setting instead.
	 *
	 *		config.pasteFromWordRemoveStyles = false;
	 *
	 * @removed 4.6.0
	 * @since 3.1
	 * @cfg {Boolean} [pasteFromWordRemoveStyles=true]
	 * @member CKEDITOR.config
	 */

<span id='CKEDITOR-config-cfg-pasteFromWord_heuristicsEdgeList'>	/**
</span>	 * Activates a heuristic that helps detect lists pasted into the editor in Microsoft Edge.
	 *
	 * The reason why this heuristic is needed is that on pasting Microsoft Edge removes any Word-specific
	 * metadata allowing to identify lists.
	 *
	 *		// Disables list heuristics for Edge.
	 *		config.pasteFromWord_heuristicsEdgeList = false;
	 *
	 * @since 4.6.2
	 * @cfg {Boolean} [pasteFromWord_heuristicsEdgeList=true]
	 * @member CKEDITOR.config
	*/
	CKEDITOR.config.pasteFromWord_heuristicsEdgeList = true;
} )();
</pre>
</body>
</html>
