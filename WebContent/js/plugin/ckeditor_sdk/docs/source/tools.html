<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='global-property-'>/**
</span> * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

<span id='global-property-'>/**
</span> * @fileOverview Defines the {@link CKEDITOR.tools} object that contains
 *		utility functions.
 */

( function() {
	var functions = [],
		cssVendorPrefix =
			CKEDITOR.env.gecko ? &#39;-moz-&#39; :
			CKEDITOR.env.webkit ? &#39;-webkit-&#39; :
			CKEDITOR.env.ie ? &#39;-ms-&#39; :
			&#39;&#39;,
		ampRegex = /&amp;/g,
		gtRegex = /&gt;/g,
		ltRegex = /&lt;/g,
		quoteRegex = /&quot;/g,
		tokenCharset = &#39;abcdefghijklmnopqrstuvwxyz0123456789&#39;,
		TOKEN_COOKIE_NAME = &#39;ckCsrfToken&#39;,
		TOKEN_LENGTH = 40,

		allEscRegex = /&amp;(lt|gt|amp|quot|nbsp|shy|#\d{1,5});/g,
		namedEntities = {
			lt: &#39;&lt;&#39;,
			gt: &#39;&gt;&#39;,
			amp: &#39;&amp;&#39;,
			quot: &#39;&quot;&#39;,
			nbsp: &#39;\u00a0&#39;,
			shy: &#39;\u00ad&#39;
		},
		allEscDecode = function( match, code ) {
			if ( code[ 0 ] == &#39;#&#39; ) {
				return String.fromCharCode( parseInt( code.slice( 1 ), 10 ) );
			} else {
				return namedEntities[ code ];
			}
		};

	CKEDITOR.on( &#39;reset&#39;, function() {
		functions = [];
	} );

<span id='CKEDITOR-tools'>	/**
</span>	 * Utility functions.
	 *
	 * @class
	 * @singleton
	 */
	CKEDITOR.tools = {
<span id='CKEDITOR-tools-method-arrayCompare'>		/**
</span>		 * Compares the elements of two arrays.
		 *
		 *		var a = [ 1, &#39;a&#39;, 3 ];
		 *		var b = [ 1, 3, &#39;a&#39; ];
		 *		var c = [ 1, &#39;a&#39;, 3 ];
		 *		var d = [ 1, &#39;a&#39;, 3, 4 ];
		 *
		 *		alert( CKEDITOR.tools.arrayCompare( a, b ) );  // false
		 *		alert( CKEDITOR.tools.arrayCompare( a, c ) );  // true
		 *		alert( CKEDITOR.tools.arrayCompare( a, d ) );  // false
		 *
		 * @param {Array} arrayA An array to be compared.
		 * @param {Array} arrayB The other array to be compared.
		 * @returns {Boolean} `true` if the arrays have the same length and
		 * their elements match.
		 */
		arrayCompare: function( arrayA, arrayB ) {
			if ( !arrayA &amp;&amp; !arrayB )
				return true;

			if ( !arrayA || !arrayB || arrayA.length != arrayB.length )
				return false;

			for ( var i = 0; i &lt; arrayA.length; i++ ) {
				if ( arrayA[ i ] != arrayB[ i ] )
					return false;
			}

			return true;
		},

<span id='CKEDITOR-tools-method-getIndex'>		/**
</span>		 * Finds the index of the first element in an array for which the `compareFunction` returns `true`.
		 *
		 *		CKEDITOR.tools.getIndex( [ 1, 2, 4, 3, 5 ], function( el ) {
		 *			return el &gt;= 3;
		 *		} ); // 2
		 *
		 * @since 4.5
		 * @param {Array} array Array to search in.
		 * @param {Function} compareFunction Compare function.
		 * @returns {Number} The index of the first matching element or `-1` if none matches.
		 */
		getIndex: function( arr, compareFunction ) {
			for ( var i = 0; i &lt; arr.length; ++i ) {
				if ( compareFunction( arr[ i ] ) )
					return i;
			}
			return -1;
		},

<span id='CKEDITOR-tools-method-clone'>		/**
</span>		 * Creates a deep copy of an object.
		 *
		 * **Note**: Recursive references are not supported.
		 *
		 *		var obj = {
		 *			name: &#39;John&#39;,
		 *			cars: {
		 *				Mercedes: { color: &#39;blue&#39; },
		 *				Porsche: { color: &#39;red&#39; }
		 *			}
		 *		};
		 *		var clone = CKEDITOR.tools.clone( obj );
		 *		clone.name = &#39;Paul&#39;;
		 *		clone.cars.Porsche.color = &#39;silver&#39;;
		 *
		 *		alert( obj.name );					// &#39;John&#39;
		 *		alert( clone.name );				// &#39;Paul&#39;
		 *		alert( obj.cars.Porsche.color );	// &#39;red&#39;
		 *		alert( clone.cars.Porsche.color );	// &#39;silver&#39;
		 *
		 * @param {Object} object The object to be cloned.
		 * @returns {Object} The object clone.
		 */
		clone: function( obj ) {
			var clone;

			// Array.
			if ( obj &amp;&amp; ( obj instanceof Array ) ) {
				clone = [];

				for ( var i = 0; i &lt; obj.length; i++ )
					clone[ i ] = CKEDITOR.tools.clone( obj[ i ] );

				return clone;
			}

			// &quot;Static&quot; types.
			if ( obj === null || ( typeof obj != &#39;object&#39; ) || ( obj instanceof String ) || ( obj instanceof Number ) || ( obj instanceof Boolean ) || ( obj instanceof Date ) || ( obj instanceof RegExp ) )
				return obj;

			// DOM objects and window.
			if ( obj.nodeType || obj.window === obj )
				return obj;

			// Objects.
			clone = new obj.constructor();

			for ( var propertyName in obj ) {
				var property = obj[ propertyName ];
				clone[ propertyName ] = CKEDITOR.tools.clone( property );
			}

			return clone;
		},

<span id='CKEDITOR-tools-method-capitalize'>		/**
</span>		 * Turns the first letter of a string to upper-case.
		 *
		 * @param {String} str
		 * @param {Boolean} [keepCase] Keep the case of 2nd to last letter.
		 * @returns {String}
		 */
		capitalize: function( str, keepCase ) {
			return str.charAt( 0 ).toUpperCase() + ( keepCase ? str.slice( 1 ) : str.slice( 1 ).toLowerCase() );
		},

<span id='CKEDITOR-tools-method-extend'>		/**
</span>		 * Copies the properties from one object to another. By default, properties
		 * already present in the target object **are not** overwritten.
		 *
		 *		// Create the sample object.
		 *		var myObject = {
		 *			prop1: true
		 *		};
		 *
		 *		// Extend the above object with two properties.
		 *		CKEDITOR.tools.extend( myObject, {
		 *			prop2: true,
		 *			prop3: true
		 *		} );
		 *
		 *		// Alert &#39;prop1&#39;, &#39;prop2&#39; and &#39;prop3&#39;.
		 *		for ( var p in myObject )
		 *			alert( p );
		 *
		 * @param {Object} target The object to be extended.
		 * @param {Object...} source The object(s) from properties will be
		 * copied. Any number of objects can be passed to this function.
		 * @param {Boolean} [overwrite] If `true` is specified, it indicates that
		 * properties already present in the target object could be
		 * overwritten by subsequent objects.
		 * @param {Object} [properties] Only properties within the specified names
		 * list will be received from the source object.
		 * @returns {Object} The extended object (target).
		 */
		extend: function( target ) {
			var argsLength = arguments.length,
				overwrite, propertiesList;

			if ( typeof ( overwrite = arguments[ argsLength - 1 ] ) == &#39;boolean&#39; )
				argsLength--;
			else if ( typeof ( overwrite = arguments[ argsLength - 2 ] ) == &#39;boolean&#39; ) {
				propertiesList = arguments[ argsLength - 1 ];
				argsLength -= 2;
			}
			for ( var i = 1; i &lt; argsLength; i++ ) {
				var source = arguments[ i ];
				for ( var propertyName in source ) {
					// Only copy existed fields if in overwrite mode.
					if ( overwrite === true || target[ propertyName ] == null ) {
						// Only copy  specified fields if list is provided.
						if ( !propertiesList || ( propertyName in propertiesList ) )
							target[ propertyName ] = source[ propertyName ];

					}
				}
			}

			return target;
		},

<span id='CKEDITOR-tools-method-prototypedCopy'>		/**
</span>		 * Creates an object which is an instance of a class whose prototype is a
		 * predefined object. All properties defined in the source object are
		 * automatically inherited by the resulting object, including future
		 * changes to it.
		 *
		 * @param {Object} source The source object to be used as the prototype for
		 * the final object.
		 * @returns {Object} The resulting copy.
		 */
		prototypedCopy: function( source ) {
			var copy = function() {};
			copy.prototype = source;
			return new copy();
		},

<span id='CKEDITOR-tools-method-copy'>		/**
</span>		 * Makes fast (shallow) copy of an object.
		 * This method is faster than {@link #clone} which does
		 * a deep copy of an object (including arrays).
		 *
		 * @since 4.1
		 * @param {Object} source The object to be copied.
		 * @returns {Object} Copy of `source`.
		 */
		copy: function( source ) {
			var obj = {},
				name;

			for ( name in source )
				obj[ name ] = source[ name ];

			return obj;
		},

<span id='CKEDITOR-tools-method-isArray'>		/**
</span>		 * Checks if an object is an Array.
		 *
		 *		alert( CKEDITOR.tools.isArray( [] ) );		// true
		 *		alert( CKEDITOR.tools.isArray( &#39;Test&#39; ) );	// false
		 *
		 * @param {Object} object The object to be checked.
		 * @returns {Boolean} `true` if the object is an Array, otherwise `false`.
		 */
		isArray: function( object ) {
			return Object.prototype.toString.call( object ) == &#39;[object Array]&#39;;
		},

<span id='CKEDITOR-tools-method-isEmpty'>		/**
</span>		 * Whether the object contains no properties of its own.
		 *
		 * @param object
		 * @returns {Boolean}
		 */
		isEmpty: function( object ) {
			for ( var i in object ) {
				if ( object.hasOwnProperty( i ) )
					return false;
			}
			return true;
		},

<span id='CKEDITOR-tools-method-cssVendorPrefix'>		/**
</span>		 * Generates an object or a string containing vendor-specific and vendor-free CSS properties.
		 *
		 *		CKEDITOR.tools.cssVendorPrefix( &#39;border-radius&#39;, &#39;0&#39;, true );
		 *		// On Firefox: &#39;-moz-border-radius:0;border-radius:0&#39;
		 *		// On Chrome: &#39;-webkit-border-radius:0;border-radius:0&#39;
		 *
		 * @param {String} property The CSS property name.
		 * @param {String} value The CSS value.
		 * @param {Boolean} [asString=false] If `true`, then the returned value will be a CSS string.
		 * @returns {Object/String} The object containing CSS properties or its stringified version.
		 */
		cssVendorPrefix: function( property, value, asString ) {
			if ( asString )
				return cssVendorPrefix + property + &#39;:&#39; + value + &#39;;&#39; + property + &#39;:&#39; + value;

			var ret = {};
			ret[ property ] = value;
			ret[ cssVendorPrefix + property ] = value;

			return ret;
		},

<span id='CKEDITOR-tools-method-cssStyleToDomStyle'>		/**
</span>		 * Transforms a CSS property name to its relative DOM style name.
		 *
		 *		alert( CKEDITOR.tools.cssStyleToDomStyle( &#39;background-color&#39; ) );	// &#39;backgroundColor&#39;
		 *		alert( CKEDITOR.tools.cssStyleToDomStyle( &#39;float&#39; ) );				// &#39;cssFloat&#39;
		 *
		 * @method
		 * @param {String} cssName The CSS property name.
		 * @returns {String} The transformed name.
		 */
		cssStyleToDomStyle: ( function() {
			var test = document.createElement( &#39;div&#39; ).style;

			var cssFloat = ( typeof test.cssFloat != &#39;undefined&#39; ) ? &#39;cssFloat&#39; : ( typeof test.styleFloat != &#39;undefined&#39; ) ? &#39;styleFloat&#39; : &#39;float&#39;;

			return function( cssName ) {
				if ( cssName == &#39;float&#39; )
					return cssFloat;
				else {
					return cssName.replace( /-./g, function( match ) {
						return match.substr( 1 ).toUpperCase();
					} );
				}
			};
		} )(),

<span id='CKEDITOR-tools-method-buildStyleHtml'>		/**
</span>		 * Builds a HTML snippet from a set of `&lt;style&gt;/&lt;link&gt;`.
		 *
		 * @param {String/Array} css Each of which are URLs (absolute) of a CSS file or
		 * a trunk of style text.
		 * @returns {String}
		 */
		buildStyleHtml: function( css ) {
			css = [].concat( css );
			var item,
				retval = [];
			for ( var i = 0; i &lt; css.length; i++ ) {
				if ( ( item = css[ i ] ) ) {
					// Is CSS style text ?
					if ( /@import|[{}]/.test( item ) )
						retval.push( &#39;&lt;style&gt;&#39; + item + &#39;&lt;/style&gt;&#39; );
					else
						retval.push( &#39;&lt;link type=&quot;text/css&quot; rel=stylesheet href=&quot;&#39; + item + &#39;&quot;&gt;&#39; );
				}
			}
			return retval.join( &#39;&#39; );
		},

<span id='CKEDITOR-tools-method-htmlEncode'>		/**
</span>		 * Replaces special HTML characters in a string with their relative HTML
		 * entity values.
		 *
		 *		alert( CKEDITOR.tools.htmlEncode( &#39;A &gt; B &amp; C &lt; D&#39; ) ); // &#39;A &amp;gt; B &amp;amp; C &amp;lt; D&#39;
		 *
		 * @param {String} text The string to be encoded.
		 * @returns {String} The encoded string.
		 */
		htmlEncode: function( text ) {
			// Backwards compatibility - accept also non-string values (casting is done below).
			// Since 4.4.8 we return empty string for null and undefined because these values make no sense.
			if ( text === undefined || text === null ) {
				return &#39;&#39;;
			}

			return String( text ).replace( ampRegex, &#39;&amp;amp;&#39; ).replace( gtRegex, &#39;&amp;gt;&#39; ).replace( ltRegex, &#39;&amp;lt;&#39; );
		},

<span id='CKEDITOR-tools-method-htmlDecode'>		/**
</span>		 * Decodes HTML entities that browsers tend to encode when used in text nodes.
		 *
		 *		alert( CKEDITOR.tools.htmlDecode( &#39;&amp;lt;a &amp;amp; b &amp;gt;&#39; ) ); // &#39;&lt;a &amp; b &gt;&#39;
		 *
		 * Read more about chosen entities in the [research](https://dev.ckeditor.com/ticket/13105#comment:8).
		 *
		 * @param {String} The string to be decoded.
		 * @returns {String} The decoded string.
		 */
		htmlDecode: function( text ) {
			// See:
			// * https://dev.ckeditor.com/ticket/13105#comment:8 and comment:9,
			// * http://jsperf.com/wth-is-going-on-with-jsperf JSPerf has some serious problems, but you can observe
			// that combined regexp tends to be quicker (except on V8). It will also not be prone to fail on &#39;&amp;amp;lt;&#39;
			// (see https://dev.ckeditor.com/ticket/13105#DXWTF:CKEDITOR.tools.htmlEnDecodeAttr).
			return text.replace( allEscRegex, allEscDecode );
		},

<span id='CKEDITOR-tools-method-htmlEncodeAttr'>		/**
</span>		 * Replaces special HTML characters in HTMLElement attribute with their relative HTML entity values.
		 *
		 *		alert( CKEDITOR.tools.htmlEncodeAttr( &#39;&lt;a &quot; b &gt;&#39; ) ); // &#39;&amp;lt;a &amp;quot; b &amp;gt;&#39;
		 *
		 * @param {String} The attribute value to be encoded.
		 * @returns {String} The encoded value.
		 */
		htmlEncodeAttr: function( text ) {
			return CKEDITOR.tools.htmlEncode( text ).replace( quoteRegex, &#39;&amp;quot;&#39; );
		},

<span id='CKEDITOR-tools-method-htmlDecodeAttr'>		/**
</span>		 * Decodes HTML entities that browsers tend to encode when used in attributes.
		 *
		 *		alert( CKEDITOR.tools.htmlDecodeAttr( &#39;&amp;lt;a &amp;quot; b&amp;gt;&#39; ) ); // &#39;&lt;a &quot; b&gt;&#39;
		 *
		 * Since CKEditor 4.5 this method simply executes {@link #htmlDecode} which covers
		 * all necessary entities.
		 *
		 * @param {String} text The text to be decoded.
		 * @returns {String} The decoded text.
		 */
		htmlDecodeAttr: function( text ) {
			return CKEDITOR.tools.htmlDecode( text );
		},

<span id='CKEDITOR-tools-method-transformPlainTextToHtml'>		/**
</span>		 * Transforms text to valid HTML: creates paragraphs, replaces tabs with non-breaking spaces etc.
		 *
		 * @since 4.5
		 * @param {String} text Text to transform.
		 * @param {Number} enterMode Editor {@link CKEDITOR.config#enterMode Enter mode}.
		 * @returns {String} HTML generated from the text.
		 */
		transformPlainTextToHtml: function( text, enterMode ) {
			var isEnterBrMode = enterMode == CKEDITOR.ENTER_BR,
				// CRLF -&gt; LF
				html = this.htmlEncode( text.replace( /\r\n/g, &#39;\n&#39; ) );

			// Tab -&gt; &amp;nbsp x 4;
			html = html.replace( /\t/g, &#39;&amp;nbsp;&amp;nbsp; &amp;nbsp;&#39; );

			var paragraphTag = enterMode == CKEDITOR.ENTER_P ? &#39;p&#39; : &#39;div&#39;;

			// Two line-breaks create one paragraphing block.
			if ( !isEnterBrMode ) {
				var duoLF = /\n{2}/g;
				if ( duoLF.test( html ) ) {
					var openTag = &#39;&lt;&#39; + paragraphTag + &#39;&gt;&#39;, endTag = &#39;&lt;/&#39; + paragraphTag + &#39;&gt;&#39;;
					html = openTag + html.replace( duoLF, function() {
						return endTag + openTag;
					} ) + endTag;
				}
			}

			// One &lt;br&gt; per line-break.
			html = html.replace( /\n/g, &#39;&lt;br&gt;&#39; );

			// Compensate padding &lt;br&gt; at the end of block, avoid loosing them during insertion.
			if ( !isEnterBrMode ) {
				html = html.replace( new RegExp( &#39;&lt;br&gt;(?=&lt;/&#39; + paragraphTag + &#39;&gt;)&#39; ), function( match ) {
					return CKEDITOR.tools.repeat( match, 2 );
				} );
			}

			// Preserve spaces at the ends, so they won&#39;t be lost after insertion (merged with adjacent ones).
			html = html.replace( /^ | $/g, &#39;&amp;nbsp;&#39; );

			// Finally, preserve whitespaces that are to be lost.
			html = html.replace( /(&gt;|\s) /g, function( match, before ) {
				return before + &#39;&amp;nbsp;&#39;;
			} ).replace( / (?=&lt;)/g, &#39;&amp;nbsp;&#39; );

			return html;
		},

<span id='CKEDITOR-tools-method-getNextNumber'>		/**
</span>		 * Gets a unique number for this CKEDITOR execution session. It returns
		 * consecutive numbers starting from 1.
		 *
		 *		alert( CKEDITOR.tools.getNextNumber() ); // (e.g.) 1
		 *		alert( CKEDITOR.tools.getNextNumber() ); // 2
		 *
		 * @method
		 * @returns {Number} A unique number.
		 */
		getNextNumber: ( function() {
			var last = 0;
			return function() {
				return ++last;
			};
		} )(),

<span id='CKEDITOR-tools-method-getNextId'>		/**
</span>		 * Gets a unique ID for CKEditor interface elements. It returns a
		 * string with the &quot;cke_&quot; prefix and a consecutive number.
		 *
		 *		alert( CKEDITOR.tools.getNextId() ); // (e.g.) &#39;cke_1&#39;
		 *		alert( CKEDITOR.tools.getNextId() ); // &#39;cke_2&#39;
		 *
		 * @returns {String} A unique ID.
		 */
		getNextId: function() {
			return &#39;cke_&#39; + this.getNextNumber();
		},

<span id='CKEDITOR-tools-method-getUniqueId'>		/**
</span>		 * Gets a universally unique ID. It returns a random string
		 * compliant with ISO/IEC 11578:1996, without dashes, with the &quot;e&quot; prefix to
		 * make sure that the ID does not start with a number.
		 *
		 * @returns {String} A global unique ID.
		 */
		getUniqueId: function() {
			var uuid = &#39;e&#39;; // Make sure that id does not start with number.
			for ( var i = 0; i &lt; 8; i++ ) {
				uuid += Math.floor( ( 1 + Math.random() ) * 0x10000 ).toString( 16 ).substring( 1 );
			}
			return uuid;
		},

<span id='CKEDITOR-tools-method-override'>		/**
</span>		 * Creates a function override.
		 *
		 *		var obj = {
		 *			myFunction: function( name ) {
		 *				alert( &#39;Name: &#39; + name );
		 *			}
		 *		};
		 *
		 *		obj.myFunction = CKEDITOR.tools.override( obj.myFunction, function( myFunctionOriginal ) {
		 *			return function( name ) {
		 *				alert( &#39;Overriden name: &#39; + name );
		 *				myFunctionOriginal.call( this, name );
		 *			};
		 *		} );
		 *
		 * @param {Function} originalFunction The function to be overridden.
		 * @param {Function} functionBuilder A function that returns the new
		 * function. The original function reference will be passed to this function.
		 * @returns {Function} The new function.
		 */
		override: function( originalFunction, functionBuilder ) {
			var newFn = functionBuilder( originalFunction );
			newFn.prototype = originalFunction.prototype;
			return newFn;
		},

<span id='CKEDITOR-tools-method-setTimeout'>		/**
</span>		 * Executes a function after a specified delay.
		 *
		 *		CKEDITOR.tools.setTimeout( function() {
		 *			alert( &#39;Executed after 2 seconds&#39; );
		 *		}, 2000 );
		 *
		 * @param {Function} func The function to be executed.
		 * @param {Number} [milliseconds=0] The amount of time (in milliseconds) to wait
		 * to fire the function execution.
		 * @param {Object} [scope=window] The object to store the function execution scope
		 * (the `this` object).
		 * @param {Object/Array} [args] A single object, or an array of objects, to
		 * pass as argument to the function.
		 * @param {Object} [ownerWindow=window] The window that will be used to set the
		 * timeout.
		 * @returns {Object} A value that can be used to cancel the function execution.
		 */
		setTimeout: function( func, milliseconds, scope, args, ownerWindow ) {
			if ( !ownerWindow )
				ownerWindow = window;

			if ( !scope )
				scope = ownerWindow;

			return ownerWindow.setTimeout( function() {
				if ( args )
					func.apply( scope, [].concat( args ) );
				else
					func.apply( scope );
			}, milliseconds || 0 );
		},

<span id='CKEDITOR-tools-method-trim'>		/**
</span>		 * Removes spaces from the start and the end of a string. The following
		 * characters are removed: space, tab, line break, line feed.
		 *
		 *		alert( CKEDITOR.tools.trim( &#39;  example &#39; ); // &#39;example&#39;
		 *
		 * @method
		 * @param {String} str The text from which the spaces will be removed.
		 * @returns {String} The modified string without the boundary spaces.
		 */
		trim: ( function() {
			// We are not using \s because we don&#39;t want &quot;non-breaking spaces&quot; to be caught.
			var trimRegex = /(?:^[ \t\n\r]+)|(?:[ \t\n\r]+$)/g;
			return function( str ) {
				return str.replace( trimRegex, &#39;&#39; );
			};
		} )(),

<span id='CKEDITOR-tools-method-ltrim'>		/**
</span>		 * Removes spaces from the start (left) of a string. The following
		 * characters are removed: space, tab, line break, line feed.
		 *
		 *		alert( CKEDITOR.tools.ltrim( &#39;  example &#39; ); // &#39;example &#39;
		 *
		 * @method
		 * @param {String} str The text from which the spaces will be removed.
		 * @returns {String} The modified string excluding the removed spaces.
		 */
		ltrim: ( function() {
			// We are not using \s because we don&#39;t want &quot;non-breaking spaces&quot; to be caught.
			var trimRegex = /^[ \t\n\r]+/g;
			return function( str ) {
				return str.replace( trimRegex, &#39;&#39; );
			};
		} )(),

<span id='CKEDITOR-tools-method-rtrim'>		/**
</span>		 * Removes spaces from the end (right) of a string. The following
		 * characters are removed: space, tab, line break, line feed.
		 *
		 *		alert( CKEDITOR.tools.ltrim( &#39;  example &#39; ); // &#39;  example&#39;
		 *
		 * @method
		 * @param {String} str The text from which spaces will be removed.
		 * @returns {String} The modified string excluding the removed spaces.
		 */
		rtrim: ( function() {
			// We are not using \s because we don&#39;t want &quot;non-breaking spaces&quot; to be caught.
			var trimRegex = /[ \t\n\r]+$/g;
			return function( str ) {
				return str.replace( trimRegex, &#39;&#39; );
			};
		} )(),

<span id='CKEDITOR-tools-method-indexOf'>		/**
</span>		 * Returns the index of an element in an array.
		 *
		 *		var letters = [ &#39;a&#39;, &#39;b&#39;, 0, &#39;c&#39;, false ];
		 *		alert( CKEDITOR.tools.indexOf( letters, &#39;0&#39; ) );		// -1 because 0 !== &#39;0&#39;
		 *		alert( CKEDITOR.tools.indexOf( letters, false ) );		// 4 because 0 !== false
		 *
		 * @param {Array} array The array to be searched.
		 * @param {Object/Function} value The element to be found. This can be an
		 * evaluation function which receives a single parameter call for
		 * each entry in the array, returning `true` if the entry matches.
		 * @returns {Number} The (zero-based) index of the first entry that matches
		 * the entry, or `-1` if not found.
		 */
		indexOf: function( array, value ) {
			if ( typeof value == &#39;function&#39; ) {
				for ( var i = 0, len = array.length; i &lt; len; i++ ) {
					if ( value( array[ i ] ) )
						return i;
				}
			} else if ( array.indexOf )
				return array.indexOf( value );
			else {
				for ( i = 0, len = array.length; i &lt; len; i++ ) {
					if ( array[ i ] === value )
						return i;
				}
			}
			return -1;
		},

<span id='CKEDITOR-tools-method-search'>		/**
</span>		 * Returns the index of an element in an array.
		 *
		 *		var obj = { prop: true };
		 *		var letters = [ &#39;a&#39;, &#39;b&#39;, 0, obj, false ];
		 *
		 *		alert( CKEDITOR.tools.indexOf( letters, &#39;0&#39; ) ); // null
		 *		alert( CKEDITOR.tools.indexOf( letters, function( value ) {
		 *			// Return true when passed value has property &#39;prop&#39;.
		 *			return value &amp;&amp; &#39;prop&#39; in value;
		 *		} ) );											// obj
		 *
		 * @param {Array} array The array to be searched.
		 * @param {Object/Function} value The element to be found. Can be an
		 * evaluation function which receives a single parameter call for
		 * each entry in the array, returning `true` if the entry matches.
		 * @returns Object The value that was found in an array.
		 */
		search: function( array, value ) {
			var index = CKEDITOR.tools.indexOf( array, value );
			return index &gt;= 0 ? array[ index ] : null;
		},

<span id='CKEDITOR-tools-method-bind'>		/**
</span>		 * Creates a function that will always execute in the context of a
		 * specified object.
		 *
		 *		var obj = { text: &#39;My Object&#39; };
		 *
		 *		function alertText() {
		 *			alert( this.text );
		 *		}
		 *
		 *		var newFunc = CKEDITOR.tools.bind( alertText, obj );
		 *		newFunc(); // Alerts &#39;My Object&#39;.
		 *
		 * @param {Function} func The function to be executed.
		 * @param {Object} obj The object to which the execution context will be bound.
		 * @returns {Function} The function that can be used to execute the
		 * `func` function in the context of `obj`.
		 */
		bind: function( func, obj ) {
			return function() {
				return func.apply( obj, arguments );
			};
		},

<span id='CKEDITOR-tools-method-createClass'>		/**
</span>		 * Class creation based on prototype inheritance which supports of the
		 * following features:
		 *
		 * * Static fields
		 * * Private fields
		 * * Public (prototype) fields
		 * * Chainable base class constructor
		 *
		 * @param {Object} definition The class definition object.
		 * @returns {Function} A class-like JavaScript function.
		 */
		createClass: function( definition ) {
			var $ = definition.$,
				baseClass = definition.base,
				privates = definition.privates || definition._,
				proto = definition.proto,
				statics = definition.statics;

			// Create the constructor, if not present in the definition.
			!$ &amp;&amp; ( $ = function() {
				baseClass &amp;&amp; this.base.apply( this, arguments );
			} );

			if ( privates ) {
				var originalConstructor = $;
				$ = function() {
					// Create (and get) the private namespace.
					var _ = this._ || ( this._ = {} );

					// Make some magic so &quot;this&quot; will refer to the main
					// instance when coding private functions.
					for ( var privateName in privates ) {
						var priv = privates[ privateName ];

						_[ privateName ] = ( typeof priv == &#39;function&#39; ) ? CKEDITOR.tools.bind( priv, this ) : priv;
					}

					originalConstructor.apply( this, arguments );
				};
			}

			if ( baseClass ) {
				$.prototype = this.prototypedCopy( baseClass.prototype );
				$.prototype.constructor = $;
				// Super references.
				$.base = baseClass;
				$.baseProto = baseClass.prototype;
				// Super constructor.
				$.prototype.base = function() {
					this.base = baseClass.prototype.base;
					baseClass.apply( this, arguments );
					this.base = arguments.callee;
				};
			}

			if ( proto )
				this.extend( $.prototype, proto, true );

			if ( statics )
				this.extend( $, statics, true );

			return $;
		},

<span id='CKEDITOR-tools-method-addFunction'>		/**
</span>		 * Creates a function reference that can be called later using
		 * {@link #callFunction}. This approach is especially useful to
		 * make DOM attribute function calls to JavaScript-defined functions.
		 *
		 *		var ref = CKEDITOR.tools.addFunction( function() {
		 *			alert( &#39;Hello!&#39;);
		 *		} );
		 *		CKEDITOR.tools.callFunction( ref ); // &#39;Hello!&#39;
		 *
		 * @param {Function} fn The function to be executed on call.
		 * @param {Object} [scope] The object to have the context on `fn` execution.
		 * @returns {Number} A unique reference to be used in conjuction with
		 * {@link #callFunction}.
		 */
		addFunction: function( fn, scope ) {
			return functions.push( function() {
				return fn.apply( scope || this, arguments );
			} ) - 1;
		},

<span id='CKEDITOR-tools-method-removeFunction'>		/**
</span>		 * Removes the function reference created with {@link #addFunction}.
		 *
		 * @param {Number} ref The function reference created with
		 * {@link #addFunction}.
		 */
		removeFunction: function( ref ) {
			functions[ ref ] = null;
		},

<span id='CKEDITOR-tools-method-callFunction'>		/**
</span>		 * Executes a function based on the reference created with {@link #addFunction}.
		 *
		 *		var ref = CKEDITOR.tools.addFunction( function() {
		 *			alert( &#39;Hello!&#39;);
		 *		} );
		 *		CKEDITOR.tools.callFunction( ref ); // &#39;Hello!&#39;
		 *
		 * @param {Number} ref The function reference created with {@link #addFunction}.
		 * @param {Mixed} params Any number of parameters to be passed to the executed function.
		 * @returns {Mixed} The return value of the function.
		 */
		callFunction: function( ref ) {
			var fn = functions[ ref ];
			return fn &amp;&amp; fn.apply( window, Array.prototype.slice.call( arguments, 1 ) );
		},

<span id='CKEDITOR-tools-method-cssLength'>		/**
</span>		 * Appends the `px` length unit to the size value if it is missing.
		 *
		 *		var cssLength = CKEDITOR.tools.cssLength;
		 *		cssLength( 42 );		// &#39;42px&#39;
		 *		cssLength( &#39;42&#39; );		// &#39;42px&#39;
		 *		cssLength( &#39;42px&#39; );	// &#39;42px&#39;
		 *		cssLength( &#39;42%&#39; );		// &#39;42%&#39;
		 *		cssLength( &#39;bold&#39; );	// &#39;bold&#39;
		 *		cssLength( false );		// &#39;&#39;
		 *		cssLength( NaN );		// &#39;&#39;
		 *
		 * @method
		 * @param {Number/String/Boolean} length
		 */
		cssLength: ( function() {
			var pixelRegex = /^-?\d+\.?\d*px$/,
				lengthTrimmed;

			return function( length ) {
				lengthTrimmed = CKEDITOR.tools.trim( length + &#39;&#39; ) + &#39;px&#39;;

				if ( pixelRegex.test( lengthTrimmed ) )
					return lengthTrimmed;
				else
					return length || &#39;&#39;;
			};
		} )(),

<span id='CKEDITOR-tools-method-convertToPx'>		/**
</span>		 * Converts the specified CSS length value to the calculated pixel length inside this page.
		 *
		 * **Note:** Percentage-based value is left intact.
		 *
		 * @method
		 * @param {String} cssLength CSS length value.
		 */
		convertToPx: ( function() {
			var calculator;

			return function( cssLength ) {
				if ( !calculator ) {
					calculator = CKEDITOR.dom.element.createFromHtml( &#39;&lt;div style=&quot;position:absolute;left:-9999px;&#39; +
						&#39;top:-9999px;margin:0px;padding:0px;border:0px;&quot;&#39; +
						&#39;&gt;&lt;/div&gt;&#39;, CKEDITOR.document );
					CKEDITOR.document.getBody().append( calculator );
				}

				if ( !( /%$/ ).test( cssLength ) ) {
					calculator.setStyle( &#39;width&#39;, cssLength );
					return calculator.$.clientWidth;
				}

				return cssLength;
			};
		} )(),

<span id='CKEDITOR-tools-method-repeat'>		/**
</span>		 * String specified by `str` repeats `times` times.
		 *
		 * @param {String} str
		 * @param {Number} times
		 * @returns {String}
		 */
		repeat: function( str, times ) {
			return new Array( times + 1 ).join( str );
		},

<span id='CKEDITOR-tools-method-tryThese'>		/**
</span>		 * Returns the first successfully executed return value of a function that
		 * does not throw any exception.
		 *
		 * @param {Function...} fn
		 * @returns {Mixed}
		 */
		tryThese: function() {
			var returnValue;
			for ( var i = 0, length = arguments.length; i &lt; length; i++ ) {
				var lambda = arguments[ i ];
				try {
					returnValue = lambda();
					break;
				} catch ( e ) {}
			}
			return returnValue;
		},

<span id='CKEDITOR-tools-method-genKey'>		/**
</span>		 * Generates a combined key from a series of params.
		 *
		 *		var key = CKEDITOR.tools.genKey( &#39;key1&#39;, &#39;key2&#39;, &#39;key3&#39; );
		 *		alert( key ); // &#39;key1-key2-key3&#39;.
		 *
		 * @param {String} subKey One or more strings used as subkeys.
		 * @returns {String}
		 */
		genKey: function() {
			return Array.prototype.slice.call( arguments ).join( &#39;-&#39; );
		},

<span id='CKEDITOR-tools-method-defer'>		/**
</span>		 * Creates a &quot;deferred&quot; function which will not run immediately,
		 * but rather runs as soon as the interpreter’s call stack is empty.
		 * Behaves much like `window.setTimeout` with a delay.
		 *
		 * **Note:** The return value of the original function will be lost.
		 *
		 * @param {Function} fn The callee function.
		 * @returns {Function} The new deferred function.
		 */
		defer: function( fn ) {
			return function() {
				var args = arguments,
					self = this;
				window.setTimeout( function() {
					fn.apply( self, args );
				}, 0 );
			};
		},

<span id='CKEDITOR-tools-method-normalizeCssText'>		/**
</span>		 * Normalizes CSS data in order to avoid differences in the style attribute.
		 *
		 * @param {String} styleText The style data to be normalized.
		 * @param {Boolean} [nativeNormalize=false] Parse the data using the browser.
		 * @returns {String} The normalized value.
		 */
		normalizeCssText: function( styleText, nativeNormalize ) {
			var props = [],
				name,
				parsedProps = CKEDITOR.tools.parseCssText( styleText, true, nativeNormalize );

			for ( name in parsedProps )
				props.push( name + &#39;:&#39; + parsedProps[ name ] );

			props.sort();

			return props.length ? ( props.join( &#39;;&#39; ) + &#39;;&#39; ) : &#39;&#39;;
		},

<span id='CKEDITOR-tools-method-convertRgbToHex'>		/**
</span>		 * Finds and converts `rgb(x,x,x)` color definition to hexadecimal notation.
		 *
		 * @param {String} styleText The style data (or just a string containing RGB colors) to be converted.
		 * @returns {String} The style data with RGB colors converted to hexadecimal equivalents.
		 */
		convertRgbToHex: function( styleText ) {
			return styleText.replace( /(?:rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\))/gi, function( match, red, green, blue ) {
				var color = [ red, green, blue ];
				// Add padding zeros if the hex value is less than 0x10.
				for ( var i = 0; i &lt; 3; i++ )
					color[ i ] = ( &#39;0&#39; + parseInt( color[ i ], 10 ).toString( 16 ) ).slice( -2 );
				return &#39;#&#39; + color.join( &#39;&#39; );
			} );
		},

<span id='CKEDITOR-tools-method-normalizeHex'>		/**
</span>		 * Normalizes hexadecimal notation so that the color string is always 6 characters long and lowercase.
		 *
		 * @param {String} styleText The style data (or just a string containing hex colors) to be converted.
		 * @returns {String} The style data with hex colors normalized.
		 */
		normalizeHex: function( styleText ) {
			return styleText.replace( /#(([0-9a-f]{3}){1,2})($|;|\s+)/gi, function( match, hexColor, hexColorPart, separator ) {
				var normalizedHexColor = hexColor.toLowerCase();
				if ( normalizedHexColor.length == 3 ) {
					var parts = normalizedHexColor.split( &#39;&#39; );
					normalizedHexColor = [ parts[ 0 ], parts[ 0 ], parts[ 1 ], parts[ 1 ], parts[ 2 ], parts[ 2 ] ].join( &#39;&#39; );
				}
				return &#39;#&#39; + normalizedHexColor + separator;
			} );
		},

<span id='CKEDITOR-tools-method-parseCssText'>		/**
</span>		 * Turns inline style text properties into one hash.
		 *
		 * @param {String} styleText The style data to be parsed.
		 * @param {Boolean} [normalize=false] Normalize properties and values
		 * (e.g. trim spaces, convert to lower case).
		 * @param {Boolean} [nativeNormalize=false] Parse the data using the browser.
		 * @returns {Object} The object containing parsed properties.
		 */
		parseCssText: function( styleText, normalize, nativeNormalize ) {
			var retval = {};

			if ( nativeNormalize ) {
				// Injects the style in a temporary span object, so the browser parses it,
				// retrieving its final format.
				var temp = new CKEDITOR.dom.element( &#39;span&#39; );
				styleText = temp.setAttribute( &#39;style&#39;, styleText ).getAttribute( &#39;style&#39; ) || &#39;&#39;;
			}

			// Normalize colors.
			if ( styleText ) {
				styleText = CKEDITOR.tools.normalizeHex( CKEDITOR.tools.convertRgbToHex( styleText ) );
			}

			// IE will leave a single semicolon when failed to parse the style text. (https://dev.ckeditor.com/ticket/3891)
			if ( !styleText || styleText == &#39;;&#39; )
				return retval;

			styleText.replace( /&amp;quot;/g, &#39;&quot;&#39; ).replace( /\s*([^:;\s]+)\s*:\s*([^;]+)\s*(?=;|$)/g, function( match, name, value ) {
				if ( normalize ) {
					name = name.toLowerCase();
					// Drop extra whitespacing from font-family.
					if ( name == &#39;font-family&#39; )
						value = value.replace( /\s*,\s*/g, &#39;,&#39; );
					value = CKEDITOR.tools.trim( value );
				}

				retval[ name ] = value;
			} );
			return retval;
		},

<span id='CKEDITOR-tools-method-writeCssText'>		/**
</span>		 * Serializes the `style name =&gt; value` hash to a style text.
		 *
		 *		var styleObj = CKEDITOR.tools.parseCssText( &#39;color: red; border: none&#39; );
		 *		console.log( styleObj.color ); // -&gt; &#39;red&#39;
		 *		CKEDITOR.tools.writeCssText( styleObj ); // -&gt; &#39;color:red; border:none&#39;
		 *		CKEDITOR.tools.writeCssText( styleObj, true ); // -&gt; &#39;border:none; color:red&#39;
		 *
		 * @since 4.1
		 * @param {Object} styles The object contaning style properties.
		 * @param {Boolean} [sort] Whether to sort CSS properties.
		 * @returns {String} The serialized style text.
		 */
		writeCssText: function( styles, sort ) {
			var name,
				stylesArr = [];

			for ( name in styles )
				stylesArr.push( name + &#39;:&#39; + styles[ name ] );

			if ( sort )
				stylesArr.sort();

			return stylesArr.join( &#39;; &#39; );
		},

<span id='CKEDITOR-tools-method-objectCompare'>		/**
</span>		 * Compares two objects.
		 *
		 * **Note:** This method performs shallow, non-strict comparison.
		 *
		 * @since 4.1
		 * @param {Object} left
		 * @param {Object} right
		 * @param {Boolean} [onlyLeft] Check only the properties that are present in the `left` object.
		 * @returns {Boolean} Whether objects are identical.
		 */
		objectCompare: function( left, right, onlyLeft ) {
			var name;

			if ( !left &amp;&amp; !right )
				return true;
			if ( !left || !right )
				return false;

			for ( name in left ) {
				if ( left[ name ] != right[ name ] )
					return false;

			}

			if ( !onlyLeft ) {
				for ( name in right ) {
					if ( left[ name ] != right[ name ] )
						return false;
				}
			}

			return true;
		},

<span id='CKEDITOR-tools-method-objectKeys'>		/**
</span>		 * Returns an array of passed object&#39;s keys.
		 *
		 *		console.log( CKEDITOR.tools.objectKeys( { foo: 1, bar: false } );
		 *		// -&gt; [ &#39;foo&#39;, &#39;bar&#39; ]
		 *
		 * @since 4.1
		 * @param {Object} obj
		 * @returns {Array} Object&#39;s keys.
		 */
		objectKeys: function( obj ) {
			var keys = [];
			for ( var i in obj )
				keys.push( i );

			return keys;
		},

<span id='CKEDITOR-tools-method-convertArrayToObject'>		/**
</span>		 * Converts an array to an object by rewriting array items
		 * to object properties.
		 *
		 *		var arr = [ &#39;foo&#39;, &#39;bar&#39;, &#39;foo&#39; ];
		 *		console.log( CKEDITOR.tools.convertArrayToObject( arr ) );
		 *		// -&gt; { foo: true, bar: true }
		 *		console.log( CKEDITOR.tools.convertArrayToObject( arr, 1 ) );
		 *		// -&gt; { foo: 1, bar: 1 }
		 *
		 * @since 4.1
		 * @param {Array} arr The array to be converted to an object.
		 * @param [fillWith=true] Set each property of an object to `fillWith` value.
		 */
		convertArrayToObject: function( arr, fillWith ) {
			var obj = {};

			if ( arguments.length == 1 )
				fillWith = true;

			for ( var i = 0, l = arr.length; i &lt; l; ++i )
				obj[ arr[ i ] ] = fillWith;

			return obj;
		},

<span id='CKEDITOR-tools-method-fixDomain'>		/**
</span>		 * Tries to fix the `document.domain` of the current document to match the
		 * parent window domain, avoiding &quot;Same Origin&quot; policy issues.
		 * This is an Internet Explorer only requirement.
		 *
		 * @since 4.1.2
		 * @returns {Boolean} `true` if the current domain is already good or if
		 * it has been fixed successfully.
		 */
		fixDomain: function() {
			var domain;

			while ( 1 ) {
				try {
					// Try to access the parent document. It throws
					// &quot;access denied&quot; if restricted by the &quot;Same Origin&quot; policy.
					domain = window.parent.document.domain;
					break;
				} catch ( e ) {
					// Calculate the value to set to document.domain.
					domain = domain ?

						// If it is not the first pass, strip one part of the
						// name. E.g.  &quot;test.example.com&quot;  =&gt; &quot;example.com&quot;
						domain.replace( /.+?(?:\.|$)/, &#39;&#39; ) :

						// In the first pass, we&#39;ll handle the
						// &quot;document.domain = document.domain&quot; case.
						document.domain;

					// Stop here if there is no more domain parts available.
					if ( !domain )
						break;

					document.domain = domain;
				}
			}

			return !!domain;
		},

<span id='CKEDITOR-tools-method-eventsBuffer'>		/**
</span>		 * Buffers `input` events (or any `input` calls)
		 * and triggers `output` not more often than once per `minInterval`.
		 *
		 *		var buffer = CKEDITOR.tools.eventsBuffer( 200, function() {
		 *			console.log( &#39;foo!&#39; );
		 *		} );
		 *
		 *		buffer.input();
		 *		// &#39;foo!&#39; logged immediately.
		 *		buffer.input();
		 *		// Nothing logged.
		 *		buffer.input();
		 *		// Nothing logged.
		 *		// ... after 200ms a single &#39;foo!&#39; will be logged.
		 *
		 * Can be easily used with events:
		 *
		 *		var buffer = CKEDITOR.tools.eventsBuffer( 200, function() {
		 *			console.log( &#39;foo!&#39; );
		 *		} );
		 *
		 *		editor.on( &#39;key&#39;, buffer.input );
		 *		// Note: There is no need to bind buffer as a context.
		 *
		 * @since 4.2.1
		 * @param {Number} minInterval Minimum interval between `output` calls in milliseconds.
		 * @param {Function} output Function that will be executed as `output`.
		 * @param {Object} [scopeObj] The object used to scope the listener call (the `this` object).
		 * @returns {Object}
		 * @returns {Function} return.input Buffer&#39;s input method.
		 * @returns {Function} return.reset Resets buffered events &amp;mdash; `output` will not be executed
		 * until next `input` is triggered.
		 */
		eventsBuffer: function( minInterval, output, scopeObj ) {
			var scheduled,
				lastOutput = 0;

			function triggerOutput() {
				lastOutput = ( new Date() ).getTime();
				scheduled = false;
				if ( scopeObj ) {
					output.call( scopeObj );
				} else {
					output();
				}
			}

			return {
				input: function() {
					if ( scheduled )
						return;

					var diff = ( new Date() ).getTime() - lastOutput;

					// If less than minInterval passed after last check,
					// schedule next for minInterval after previous one.
					if ( diff &lt; minInterval )
						scheduled = setTimeout( triggerOutput, minInterval - diff );
					else
						triggerOutput();
				},

				reset: function() {
					if ( scheduled )
						clearTimeout( scheduled );

					scheduled = lastOutput = 0;
				}
			};
		},

<span id='CKEDITOR-tools-method-enableHtml5Elements'>		/**
</span>		 * Enables HTML5 elements for older browsers (IE8) in the passed document.
		 *
		 * In IE8 this method can also be executed on a document fragment.
		 *
		 * **Note:** This method has to be used in the `&lt;head&gt;` section of the document.
		 *
		 * @since 4.3
		 * @param {Object} doc Native `Document` or `DocumentFragment` in which the elements will be enabled.
		 * @param {Boolean} [withAppend] Whether to append created elements to the `doc`.
		 */
		enableHtml5Elements: function( doc, withAppend ) {
			var els = &#39;abbr,article,aside,audio,bdi,canvas,data,datalist,details,figcaption,figure,footer,header,hgroup,main,mark,meter,nav,output,progress,section,summary,time,video&#39;.split( &#39;,&#39; ),
				i = els.length,
				el;

			while ( i-- ) {
				el = doc.createElement( els[ i ] );
				if ( withAppend )
					doc.appendChild( el );
			}
		},

<span id='CKEDITOR-tools-method-checkIfAnyArrayItemMatches'>		/**
</span>		 * Checks if any of the `arr` items match the provided regular expression.
		 *
		 * @param {Array} arr The array whose items will be checked.
		 * @param {RegExp} regexp The regular expression.
		 * @returns {Boolean} Returns `true` for the first occurrence of the search pattern.
		 * @since 4.4
		 */
		checkIfAnyArrayItemMatches: function( arr, regexp ) {
			for ( var i = 0, l = arr.length; i &lt; l; ++i ) {
				if ( arr[ i ].match( regexp ) )
					return true;
			}
			return false;
		},

<span id='CKEDITOR-tools-method-checkIfAnyObjectPropertyMatches'>		/**
</span>		 * Checks if any of the `obj` properties match the provided regular expression.
		 *
		 * @param obj The object whose properties will be checked.
		 * @param {RegExp} regexp The regular expression.
		 * @returns {Boolean} Returns `true` for the first occurrence of the search pattern.
		 * @since 4.4
		 */
		checkIfAnyObjectPropertyMatches: function( obj, regexp ) {
			for ( var i in obj ) {
				if ( i.match( regexp ) )
					return true;
			}
			return false;
		},

<span id='CKEDITOR-tools-method-keystrokeToString'>		/**
</span>		 * Converts a keystroke to its string representation. Returns exactly the same
		 * members as {@link #keystrokeToArray}, but the returned object contains strings of
		 * keys joined with &quot;+&quot; rather than an array of keystrokes.
		 *
		 * 		var lang = editor.lang.common.keyboard;
		 * 		var shortcut = CKEDITOR.tools.keystrokeToString( lang, CKEDITOR.CTRL + 88 );
		 * 		console.log( shortcut.display ); // &#39;Ctrl + X&#39;, on Mac &#39;⌘ + X&#39;.
		 * 		console.log( shortcut.aria ); // &#39;Ctrl + X&#39;, on Mac &#39;Cmd + X&#39;.
		 *
		 * @since 4.6.0
		 * @param {Object} lang A language object with the key name translation.
		 * @param {Number} keystroke The keystroke to convert.
		 * @returns {{display: String, aria: String}} See {@link #keystrokeToArray}.
		 */
		keystrokeToString: function( lang, keystroke ) {
			var ret = this.keystrokeToArray( lang, keystroke );

			ret.display = ret.display.join( &#39;+&#39; );
			ret.aria = ret.aria.join( &#39;+&#39; );

			return ret;
		},

<span id='CKEDITOR-tools-method-keystrokeToArray'>		/**
</span>		 * Converts a keystroke to its string representation. Returns an object with two fields:
		 *
		 * * `display` &amp;ndash; An array of strings that should be used for visible labels.
		 * For Mac devices it uses `⌥` for &lt;kbd&gt;Alt&lt;/kbd&gt;, `⇧` for &lt;kbd&gt;Shift&lt;/kbd&gt; and
		 * `⌘` for &lt;kbd&gt;Command&lt;/kbd&gt;.
		 * * `aria` &amp;ndash; An array of strings that should be used for ARIA descriptions.
		 * It does not use special characters such as `⌥`, `⇧` or `⌘`.
		 *
		 * 		var lang = editor.lang.common.keyboard;
		 * 		var shortcut = CKEDITOR.tools.keystrokeToArray( lang, CKEDITOR.CTRL + 88 );
		 * 		console.log( shortcut.display ); // [ &#39;CTRL&#39;, &#39;X&#39; ], on Mac [ &#39;⌘&#39;, &#39;X&#39; ].
		 * 		console.log( shortcut.aria ); // [ &#39;CTRL&#39;, &#39;X&#39; ], on Mac [ &#39;COMMAND&#39;, &#39;X&#39; ].
		 *
		 * @since 4.8.0
		 * @param {Object} lang A language object with the key name translation.
		 * @param {Number} keystroke The keystroke to convert.
		 * @returns {{display: String[], aria: String[]}}
		 */
		keystrokeToArray: function( lang, keystroke ) {
			var special = keystroke &amp; 0xFF0000,
				key = keystroke &amp; 0x00FFFF,
				isMac = CKEDITOR.env.mac,
				CTRL = 17,
				CMD = 224,
				ALT = 18,
				SHIFT = 16,
				display = [],
				aria = [];


			if ( special &amp; CKEDITOR.CTRL ) {
				display.push( isMac ? &#39;⌘&#39; : lang[ CTRL ] );
				aria.push( isMac ? lang[ CMD ] : lang[ CTRL ] );
			}

			if ( special &amp; CKEDITOR.ALT ) {
				display.push( isMac ? &#39;⌥&#39; : lang[ ALT ] );
				aria.push( lang[ ALT ] );
			}

			if ( special &amp; CKEDITOR.SHIFT ) {
				display.push( isMac ? &#39;⇧&#39; : lang[ SHIFT ] );
				aria.push( lang[ SHIFT ] );
			}

			if ( key ) {
				if ( lang[ key ] ) {
					display.push( lang[ key ] );
					aria.push( lang[ key ] );
				} else {
					display.push( String.fromCharCode( key ) );
					aria.push( String.fromCharCode( key ) );
				}
			}

			return {
				display: display,
				aria: aria
			};
		},

<span id='CKEDITOR-tools-property-transparentImageData'>		/**
</span>		 * The data URI of a transparent image. May be used e.g. in HTML as an image source or in CSS in `url()`.
		 *
		 * @since 4.4
		 * @readonly
		 */
		transparentImageData: &#39;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&#39;,


<span id='CKEDITOR-tools-method-getCookie'>		/**
</span>		 * Returns the value of the cookie with a given name or `null` if the cookie is not found.
		 *
		 * @since 4.5.6
		 * @param {String} name
		 * @returns {String}
		 */
		getCookie: function( name ) {
			name = name.toLowerCase();
			var parts = document.cookie.split( &#39;;&#39; );
			var pair, key;

			for ( var i = 0; i &lt; parts.length; i++ ) {
				pair = parts[ i ].split( &#39;=&#39; );
				key = decodeURIComponent( CKEDITOR.tools.trim( pair[ 0 ] ).toLowerCase() );

				if ( key === name ) {
					return decodeURIComponent( pair.length &gt; 1 ? pair[ 1 ] : &#39;&#39; );
				}
			}

			return null;
		},

<span id='CKEDITOR-tools-method-setCookie'>		/**
</span>		 * Sets the value of the cookie with a given name.
		 *
		 * @since 4.5.6
		 * @param {String} name
		 * @param {String} value
		 */
		setCookie: function( name, value ) {
			document.cookie = encodeURIComponent( name ) + &#39;=&#39; + encodeURIComponent( value ) + &#39;;path=/&#39;;
		},

<span id='CKEDITOR-tools-method-getCsrfToken'>		/**
</span>		 * Returns the CSRF token value. The value is a hash stored in `document.cookie`
		 * under the `ckCsrfToken` key. The CSRF token can be used to secure the communication
		 * between the web browser and the server, i.e. for the file upload feature in the editor.
		 *
		 * @since 4.5.6
		 * @returns {String}
		 */
		getCsrfToken: function() {
			var token = CKEDITOR.tools.getCookie( TOKEN_COOKIE_NAME );

			if ( !token || token.length != TOKEN_LENGTH ) {
				token = generateToken( TOKEN_LENGTH );
				CKEDITOR.tools.setCookie( TOKEN_COOKIE_NAME, token );
			}

			return token;
		},

<span id='CKEDITOR-tools-method-escapeCss'>		/**
</span>		 * Returns an escaped CSS selector. `CSS.escape()` is used if defined, leading digit is escaped otherwise.
		 *
		 * @since 4.5.10
		 * @param {String} selector A CSS selector to escape.
		 * @returns {String} An escaped selector.
		 */
		escapeCss: function( selector ) {
			// Invalid input.
			if ( !selector ) {
				return &#39;&#39;;
			}

			// CSS.escape() can be used.
			if ( window.CSS &amp;&amp; CSS.escape ) {
				return CSS.escape( selector );
			}

			// Simple leading digit escape.
			if ( !isNaN( parseInt( selector.charAt( 0 ), 10 ) ) ) {
				return &#39;\\3&#39; + selector.charAt( 0 ) + &#39; &#39; + selector.substring( 1, selector.length );
			}

			return selector;
		},

<span id='CKEDITOR-tools-method-getMouseButton'>		/**
</span>		 * Detects which mouse button generated a given DOM event.
		 *
		 * @since 4.7.3
		 * @param {CKEDITOR.dom.event} evt DOM event.
		 * @returns {Number|Boolean} Returns a number indicating the mouse button or `false`
		 * if the mouse button cannot be determined.
		 */
		getMouseButton: function( evt ) {
			var evtData = evt.data,
				domEvent = evtData &amp;&amp; evtData.$;

			if ( !( evtData &amp;&amp; domEvent ) ) {
				// Added in case when there&#39;s no data available. That&#39;s the case in some unit test in built version which
				// mock event but doesn&#39;t put data object.
				return false;
			}

			if ( CKEDITOR.env.ie &amp;&amp; CKEDITOR.env.version &lt; 9 ) {
				if ( domEvent.button === 4 ) {
					return CKEDITOR.MOUSE_BUTTON_MIDDLE;
				} else if ( domEvent.button === 1 ) {
					return CKEDITOR.MOUSE_BUTTON_LEFT;
				} else {
					return CKEDITOR.MOUSE_BUTTON_RIGHT;
				}
			}

			return domEvent.button;
		},

<span id='CKEDITOR-tools-method-convertHexStringToBytes'>		/**
</span>		 * Convert hex string to array containing 1 byte in each cell. Bytes are represented as Integer numbers.
		 *
		 * @since 4.8.0
		 * @param {String} hexString Contains input string which represent bytes, e.g. `&quot;08A11D8ADA2B&quot;`.
		 * @returns {Number[]} Bytes stored in a form of Integer numbers, e.g. `[ 8, 161, 29, 138, 218, 43 ]`.
		 */
		convertHexStringToBytes: function( hexString ) {
			var bytesArray = [],
				bytesArrayLength = hexString.length / 2,
				i;

			for ( i = 0; i &lt; bytesArrayLength; i++ ) {
				bytesArray.push( parseInt( hexString.substr( i * 2, 2 ), 16 ) );
			}
			return bytesArray;
		},

<span id='CKEDITOR-tools-method-convertBytesToBase64'>		/**
</span>		 * Convert bytes array into a base64 encoded string.
		 *
		 * @since 4.8.0
		 * @param {Number[]} bytesArray An array which stores 1 byte in each cell as an Integer number.
		 * @returns {String} Base64 string which represents input bytes.
		 */
		convertBytesToBase64: function( bytesArray ) {
			// Bytes are `8bit` numbers, where base64 use `6bit` to store data. That&#39;s why we process 3 Bytes into 4 characters representing base64.
			//
			// Algorithm:
			// 1. Take `3 * 8bit`.
			// 2. If there is less than 3 bytes, fill empty bits with zeros.
			// 3. Transform `3 * 8bit` into `4 * 6bit` numbers.
			// 4. Translate those numbers to proper characters related to base64.
			// 5. If extra zero bytes were added fill them with `=` sign.
			//
			// Example:
			// 1. Bytes Array: [ 8, 161, 29, 138, 218, 43 ] -&gt; binary: `0000 1000 1010 0001 0001 1101 1000 1010 1101 1010 0010 1011`.
			// 2. Binary: `0000 10|00 1010| 0001 00|01 1101| 1000 10|10 1101| 1010 00|10 1011` ← `|` (pipe) shows where base64 will cut bits during transformation.
			// 3. Now we have 6bit numbers (written in decimal values), which are translated to indexes in `base64characters` array.
			//    Decimal: `2 10 4 29 34 45 40 43` → base64: `CKEditor`.
			var base64characters = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#39;,
				base64string = &#39;&#39;,
				bytesArrayLength = bytesArray.length,
				i;

			for ( i = 0; i &lt; bytesArrayLength; i += 3 ) {
				var array3 = bytesArray.slice( i, i + 3 ),
					array3length = array3.length,
					array4 = [],
					j;

				if ( array3length &lt; 3 ) {
					for ( j = array3length; j &lt; 3; j++ ) {
						array3[ j ] = 0;
					}
				}

				// 0xFC -&gt; 11111100 || 0x03 -&gt; 00000011 || 0x0F -&gt; 00001111 || 0xC0 -&gt; 11000000 || 0x3F -&gt; 00111111
				array4[ 0 ] = ( array3[ 0 ] &amp; 0xFC ) &gt;&gt; 2;
				array4[ 1 ] = ( ( array3[ 0 ] &amp; 0x03 ) &lt;&lt; 4 ) | ( array3[ 1 ] &gt;&gt; 4 );
				array4[ 2 ] = ( ( array3[ 1 ] &amp; 0x0F ) &lt;&lt; 2 ) | ( ( array3[ 2 ] &amp; 0xC0 ) &gt;&gt; 6 );
				array4[ 3 ] = array3[ 2 ] &amp; 0x3F;

				for ( j = 0; j &lt; 4; j++ ) {
					// Example: if array3length == 1, then we need to add 2 equal signs at the end of base64.
					// array3[ 0 ] is used to calculate array4[ 0 ] and array4[ 1 ], so there will be regular values,
					// next two ones have to be replaced with `=`, because array3[ 1 ] and array3[ 2 ] wasn&#39;t present in the input string.
					if ( j &lt;= array3length ) {
						base64string += base64characters.charAt( array4[ j ] );
					} else {
						base64string += &#39;=&#39;;
					}
				}

			}
			return base64string;
		},

<span id='CKEDITOR-tools-property-style'>		/**
</span>		 * A set of functions for operations on styles.
		 *
		 * @property {CKEDITOR.tools.style}
		 */
		style: {
<span id='CKEDITOR-tools-style-property-parse'>			/**
</span>			 * Methods to parse miscellaneous CSS properties.
			 *
			 * @property {CKEDITOR.tools.style.parse}
			 * @member CKEDITOR.tools.style
			 */
			parse: {
				// Color list based on https://www.w3.org/TR/css-color-4/#named-colors.
				_colors: {
					aliceblue: &#39;#F0F8FF&#39;,
					antiquewhite: &#39;#FAEBD7&#39;,
					aqua: &#39;#00FFFF&#39;,
					aquamarine: &#39;#7FFFD4&#39;,
					azure: &#39;#F0FFFF&#39;,
					beige: &#39;#F5F5DC&#39;,
					bisque: &#39;#FFE4C4&#39;,
					black: &#39;#000000&#39;,
					blanchedalmond: &#39;#FFEBCD&#39;,
					blue: &#39;#0000FF&#39;,
					blueviolet: &#39;#8A2BE2&#39;,
					brown: &#39;#A52A2A&#39;,
					burlywood: &#39;#DEB887&#39;,
					cadetblue: &#39;#5F9EA0&#39;,
					chartreuse: &#39;#7FFF00&#39;,
					chocolate: &#39;#D2691E&#39;,
					coral: &#39;#FF7F50&#39;,
					cornflowerblue: &#39;#6495ED&#39;,
					cornsilk: &#39;#FFF8DC&#39;,
					crimson: &#39;#DC143C&#39;,
					cyan: &#39;#00FFFF&#39;,
					darkblue: &#39;#00008B&#39;,
					darkcyan: &#39;#008B8B&#39;,
					darkgoldenrod: &#39;#B8860B&#39;,
					darkgray: &#39;#A9A9A9&#39;,
					darkgreen: &#39;#006400&#39;,
					darkgrey: &#39;#A9A9A9&#39;,
					darkkhaki: &#39;#BDB76B&#39;,
					darkmagenta: &#39;#8B008B&#39;,
					darkolivegreen: &#39;#556B2F&#39;,
					darkorange: &#39;#FF8C00&#39;,
					darkorchid: &#39;#9932CC&#39;,
					darkred: &#39;#8B0000&#39;,
					darksalmon: &#39;#E9967A&#39;,
					darkseagreen: &#39;#8FBC8F&#39;,
					darkslateblue: &#39;#483D8B&#39;,
					darkslategray: &#39;#2F4F4F&#39;,
					darkslategrey: &#39;#2F4F4F&#39;,
					darkturquoise: &#39;#00CED1&#39;,
					darkviolet: &#39;#9400D3&#39;,
					deeppink: &#39;#FF1493&#39;,
					deepskyblue: &#39;#00BFFF&#39;,
					dimgray: &#39;#696969&#39;,
					dimgrey: &#39;#696969&#39;,
					dodgerblue: &#39;#1E90FF&#39;,
					firebrick: &#39;#B22222&#39;,
					floralwhite: &#39;#FFFAF0&#39;,
					forestgreen: &#39;#228B22&#39;,
					fuchsia: &#39;#FF00FF&#39;,
					gainsboro: &#39;#DCDCDC&#39;,
					ghostwhite: &#39;#F8F8FF&#39;,
					gold: &#39;#FFD700&#39;,
					goldenrod: &#39;#DAA520&#39;,
					gray: &#39;#808080&#39;,
					green: &#39;#008000&#39;,
					greenyellow: &#39;#ADFF2F&#39;,
					grey: &#39;#808080&#39;,
					honeydew: &#39;#F0FFF0&#39;,
					hotpink: &#39;#FF69B4&#39;,
					indianred: &#39;#CD5C5C&#39;,
					indigo: &#39;#4B0082&#39;,
					ivory: &#39;#FFFFF0&#39;,
					khaki: &#39;#F0E68C&#39;,
					lavender: &#39;#E6E6FA&#39;,
					lavenderblush: &#39;#FFF0F5&#39;,
					lawngreen: &#39;#7CFC00&#39;,
					lemonchiffon: &#39;#FFFACD&#39;,
					lightblue: &#39;#ADD8E6&#39;,
					lightcoral: &#39;#F08080&#39;,
					lightcyan: &#39;#E0FFFF&#39;,
					lightgoldenrodyellow: &#39;#FAFAD2&#39;,
					lightgray: &#39;#D3D3D3&#39;,
					lightgreen: &#39;#90EE90&#39;,
					lightgrey: &#39;#D3D3D3&#39;,
					lightpink: &#39;#FFB6C1&#39;,
					lightsalmon: &#39;#FFA07A&#39;,
					lightseagreen: &#39;#20B2AA&#39;,
					lightskyblue: &#39;#87CEFA&#39;,
					lightslategray: &#39;#778899&#39;,
					lightslategrey: &#39;#778899&#39;,
					lightsteelblue: &#39;#B0C4DE&#39;,
					lightyellow: &#39;#FFFFE0&#39;,
					lime: &#39;#00FF00&#39;,
					limegreen: &#39;#32CD32&#39;,
					linen: &#39;#FAF0E6&#39;,
					magenta: &#39;#FF00FF&#39;,
					maroon: &#39;#800000&#39;,
					mediumaquamarine: &#39;#66CDAA&#39;,
					mediumblue: &#39;#0000CD&#39;,
					mediumorchid: &#39;#BA55D3&#39;,
					mediumpurple: &#39;#9370DB&#39;,
					mediumseagreen: &#39;#3CB371&#39;,
					mediumslateblue: &#39;#7B68EE&#39;,
					mediumspringgreen: &#39;#00FA9A&#39;,
					mediumturquoise: &#39;#48D1CC&#39;,
					mediumvioletred: &#39;#C71585&#39;,
					midnightblue: &#39;#191970&#39;,
					mintcream: &#39;#F5FFFA&#39;,
					mistyrose: &#39;#FFE4E1&#39;,
					moccasin: &#39;#FFE4B5&#39;,
					navajowhite: &#39;#FFDEAD&#39;,
					navy: &#39;#000080&#39;,
					oldlace: &#39;#FDF5E6&#39;,
					olive: &#39;#808000&#39;,
					olivedrab: &#39;#6B8E23&#39;,
					orange: &#39;#FFA500&#39;,
					orangered: &#39;#FF4500&#39;,
					orchid: &#39;#DA70D6&#39;,
					palegoldenrod: &#39;#EEE8AA&#39;,
					palegreen: &#39;#98FB98&#39;,
					paleturquoise: &#39;#AFEEEE&#39;,
					palevioletred: &#39;#DB7093&#39;,
					papayawhip: &#39;#FFEFD5&#39;,
					peachpuff: &#39;#FFDAB9&#39;,
					peru: &#39;#CD853F&#39;,
					pink: &#39;#FFC0CB&#39;,
					plum: &#39;#DDA0DD&#39;,
					powderblue: &#39;#B0E0E6&#39;,
					purple: &#39;#800080&#39;,
					rebeccapurple: &#39;#663399&#39;,
					red: &#39;#FF0000&#39;,
					rosybrown: &#39;#BC8F8F&#39;,
					royalblue: &#39;#4169E1&#39;,
					saddlebrown: &#39;#8B4513&#39;,
					salmon: &#39;#FA8072&#39;,
					sandybrown: &#39;#F4A460&#39;,
					seagreen: &#39;#2E8B57&#39;,
					seashell: &#39;#FFF5EE&#39;,
					sienna: &#39;#A0522D&#39;,
					silver: &#39;#C0C0C0&#39;,
					skyblue: &#39;#87CEEB&#39;,
					slateblue: &#39;#6A5ACD&#39;,
					slategray: &#39;#708090&#39;,
					slategrey: &#39;#708090&#39;,
					snow: &#39;#FFFAFA&#39;,
					springgreen: &#39;#00FF7F&#39;,
					steelblue: &#39;#4682B4&#39;,
					tan: &#39;#D2B48C&#39;,
					teal: &#39;#008080&#39;,
					thistle: &#39;#D8BFD8&#39;,
					tomato: &#39;#FF6347&#39;,
					turquoise: &#39;#40E0D0&#39;,
					violet: &#39;#EE82EE&#39;,
					wheat: &#39;#F5DEB3&#39;,
					white: &#39;#FFFFFF&#39;,
					whitesmoke: &#39;#F5F5F5&#39;,
					yellow: &#39;#FFFF00&#39;,
					yellowgreen: &#39;#9ACD32&#39;
				},

				_borderStyle: [
					&#39;none&#39;,
					&#39;hidden&#39;,
					&#39;dotted&#39;,
					&#39;dashed&#39;,
					&#39;solid&#39;,
					&#39;double&#39;,
					&#39;groove&#39;,
					&#39;ridge&#39;,
					&#39;inset&#39;,
					&#39;outset&#39;
				],

				_widthRegExp: /^(thin|medium|thick|[\+-]?\d+(\.\d+)?[a-z%]+|[\+-]?0+(\.0+)?|\.\d+[a-z%]+)$/,

				_rgbaRegExp: /rgba?\(\s*\d+%?\s*,\s*\d+%?\s*,\s*\d+%?\s*(?:,\s*[0-9.]+\s*)?\)/gi,

				_hslaRegExp: /hsla?\(\s*[0-9.]+\s*,\s*\d+%\s*,\s*\d+%\s*(?:,\s*[0-9.]+\s*)?\)/gi,

<span id='CKEDITOR-tools-style-parse-method-background'>				/**
</span>				 * Parses the `value` used as a `background` property shorthand and returns information as an object.
				 *
				 * **Note:** Currently only the `color` property is extracted. Any other parts will go into the `unprocessed` property.
				 *
				 *		var background = CKEDITOR.tools.style.parse.background( &#39;#0C0 url(foo.png)&#39; );
				 *		console.log( background );
				 *		// Logs: { color: &#39;#0C0&#39;, unprocessed: &#39;url(foo.png)&#39; }
				 *
				 * @param {String} value The value of the `background` property.
				 * @returns {Object} An object with information extracted from the background.
				 * @returns {String} return.color The **first** color value found. The color format remains the same as in input.
				 * @returns {String} return.unprocessed The remaining part of the `value` that has not been processed.
				 * @member CKEDITOR.tools.style.parse
				 */
				background: function( value ) {
					var ret = {},
						colors = this._findColor( value );

					if ( colors.length ) {
						ret.color = colors[ 0 ];

						CKEDITOR.tools.array.forEach( colors, function( colorToken ) {
							value = value.replace( colorToken, &#39;&#39; );
						} );
					}

					value = CKEDITOR.tools.trim( value );

					if ( value ) {
						// If anything was left unprocessed include it as unprocessed part.
						ret.unprocessed = value;
					}

					return ret;
				},

<span id='CKEDITOR-tools-style-parse-method-margin'>				/**
</span>				 * Parses the `margin` CSS property shorthand format.
				 *
				 *		console.log( CKEDITOR.tools.parse.margin( &#39;3px 0 2&#39; ) );
				 *		// Logs: { top: &quot;3px&quot;, right: &quot;0&quot;, bottom: &quot;2&quot;, left: &quot;0&quot; }
				 *
				 * @param {String} value The `margin` property value.
				 * @returns {Object}
				 * @returns {Number} return.top Top margin.
				 * @returns {Number} return.right Right margin.
				 * @returns {Number} return.bottom Bottom margin.
				 * @returns {Number} return.left Left margin.
				 * @member CKEDITOR.tools.style.parse
				 */
				margin: function( value ) {
					var ret = {};

					var widths = value.match( /(?:\-?[\.\d]+(?:%|\w*)|auto|inherit|initial|unset)/g ) || [ &#39;0px&#39; ];

					switch ( widths.length ) {
						case 1:
							mapStyles( [ 0, 0, 0, 0 ] );
							break;
						case 2:
							mapStyles( [ 0, 1, 0, 1 ] );
							break;
						case 3:
							mapStyles( [ 0, 1, 2, 1 ] );
							break;
						case 4:
							mapStyles( [ 0, 1, 2, 3 ] );
							break;
					}

					function mapStyles( map ) {
						ret.top = widths[ map[ 0 ] ];
						ret.right = widths[ map[ 1 ] ];
						ret.bottom = widths[ map[ 2 ] ];
						ret.left = widths[ map[ 3 ] ];
					}

					return ret;
				},

<span id='CKEDITOR-tools-style-parse-method-border'>				/**
</span>				 * Parses the `border` CSS property shorthand format.
				 * This CSS property does not support inheritance (https://www.w3.org/TR/css3-background/#the-border-shorthands).
				 *
				 *		console.log( CKEDITOR.tools.style.parse.border( &#39;3px solid #ffeedd&#39; ) );
				 *		// Logs: { width: &quot;3px&quot;, style: &quot;solid&quot;, color: &quot;#ffeedd&quot; }
				 *
				 * @param {String} value The `border` property value.
				 * @returns {Object}
				 * @returns {String} return.width The border-width attribute.
				 * @returns {String} return.style The border-style attribute.
				 * @returns {String} return.color The border-color attribute.
				 * @member CKEDITOR.tools.style.parse
				 */
				border: function( value ) {
					var ret = {},
						input = value.split( /\s+/ );

					CKEDITOR.tools.array.forEach( input, function( val ) {
						if ( !ret.color ) {
							var parseColor = CKEDITOR.tools.style.parse._findColor( val );
							if ( parseColor.length ) {
								ret.color = parseColor[ 0 ];
								return;
							}
						}

						if ( !ret.style ) {
							if ( CKEDITOR.tools.indexOf( CKEDITOR.tools.style.parse._borderStyle, val ) !== -1 ) {
								ret.style = val;
								return;
							}
						}

						if ( !ret.width ) {
							if ( CKEDITOR.tools.style.parse._widthRegExp.test( val ) ) {
								ret.width = val;
								return;
							}
						}

					} );
					return ret;
				},

<span id='CKEDITOR-tools-style-parse-method-_findColor'>				/**
</span>				 * Searches the `value` for any CSS color occurrences and returns it.
				 *
				 * @private
				 * @param {String} value
				 * @returns {String[]} An array of matched results.
				 * @member CKEDITOR.tools.style.parse
				 */
				_findColor: function( value ) {
					var ret = [],
						arrayTools = CKEDITOR.tools.array;


					// Check for rgb(a).
					ret = ret.concat( value.match( this._rgbaRegExp ) || [] );

					// Check for hsl(a).
					ret = ret.concat( value.match( this._hslaRegExp ) || [] );

					ret = ret.concat( arrayTools.filter( value.split( /\s+/ ), function( colorEntry ) {
						// Check for hex format.
						if ( colorEntry.match( /^\#[a-f0-9]{3}(?:[a-f0-9]{3})?$/gi ) ) {
							return true;
						}

						// Check for preset names.
						return colorEntry.toLowerCase() in CKEDITOR.tools.style.parse._colors;
					} ) );

					return ret;
				}
			}
		},

<span id='CKEDITOR-tools-property-array'>		/**
</span>		 * A set of array helpers.
		 *
		 * @property {CKEDITOR.tools.array}
		 * @member CKEDITOR.tools
		 */
		array: {
<span id='CKEDITOR-tools-array-method-filter'>			/**
</span>			 * Returns a copy of `array` filtered using the `fn` function. Any elements that the `fn` will return `false` for
			 * will get removed from the returned array.
			 *
			 *		var filtered = this.array.filter( [ 0, 1, 2, 3 ], function( value ) {
			 *			// Leave only values equal or greater than 2.
			 *			return value &gt;= 2;
			 *		} );
			 *		console.log( filtered );
			 *		// Logs: [ 2, 3 ]
			 *
			 * @param {Array} array
			 * @param {Function} fn A function that gets called with each `array` item. Any item that `fn`
			 * returned a `false`-alike value for will be filtered out of the `array`.
			 * @param {Mixed} fn.value The currently iterated array value.
			 * @param {Number} fn.index The index of the currently iterated value in an array.
			 * @param {Array} fn.array The original array passed as the `array` variable.
			 * @param {Mixed} [thisArg=undefined] A context object for `fn`.
			 * @returns {Array} The filtered array.
			 * @member CKEDITOR.tools.array
			 */
			filter: function( array, fn, thisArg ) {
				var ret = [];

				this.forEach( array, function( val, i ) {
					if ( fn.call( thisArg, val, i, array ) ) {
						ret.push( val );
					}
				} );

				return ret;
			},

<span id='CKEDITOR-tools-array-method-forEach'>			/**
</span>			 * Iterates over every element in the `array`.
			 *
			 * @param {Array} array An array to be iterated over.
			 * @param {Function} fn The function called for every `array` element.
			 * @param {Mixed} fn.value The currently iterated array value.
			 * @param {Number} fn.index The index of the currently iterated value in an array.
			 * @param {Array} fn.array The original array passed as an `array` variable.
			 * @param {Mixed} [thisArg=undefined] The context object for `fn`.
			 * @member CKEDITOR.tools.array
			 */
			forEach: function( array, fn, thisArg ) {
				var len = array.length,
					i;

				for ( i = 0; i &lt; len; i++ ) {
					fn.call( thisArg, array[ i ], i, array );
				}
			},

<span id='CKEDITOR-tools-array-method-map'>			/**
</span>			 * Applies a function to each element of an array and returns the array of results in the same order.
			 * Note the order of the parameters.
			 *
			 * @param {Array} array An array of elements that `fn` is applied on.
			 * @param {Function} fn A function with the signature `a -&gt; b`.
			 * @param {Mixed} [thisArg=undefined] The context object for `fn`.
			 * @returns {Array} An array of mapped elements.
			 * @member CKEDITOR.tools.array
			 * @since 4.6.2
			 */
			map: function( array, fn, thisArg ) {
				var result = [];
				for ( var i = 0; i &lt; array.length; i++ ) {
					result.push( fn.call( thisArg, array[ i ], i, array ) );
				}
				return result;
			},

<span id='CKEDITOR-tools-array-method-reduce'>			/**
</span>			 * Applies a function against each value in an array storing the result in an accumulator passed to the next iteration.
			 * Note the order of the parameters.
			 *
			 * @param {Array} array An array of elements that `fn` is applied on.
			 * @param {Function} fn A function with the signature `(accumulator, a, index, array) -&gt; b`.
			 * @param {Mixed} initial Initial value of the accumulator.
			 * @param {Mixed} [thisArg=undefined] The context object for `fn`.
			 * @returns {Mixed} The final value of the accumulator.
			 * @member CKEDITOR.tools.array
			 * @since 4.6.2
			*/
			reduce: function( array, fn, initial, thisArg ) {
				var acc = initial;
				for ( var i = 0; i &lt; array.length; i++ ) {
					acc = fn.call( thisArg, acc, array[ i ], i, array );
				}
				return acc;
			},

<span id='CKEDITOR-tools-array-method-every'>			/**
</span>			 * Tests whether all elements in an array pass the test implemented by the provided function.
			 * Returns `true` if the provided array is empty.
			 *
			 *		var every = this.array.every( [ 11, 22, 33, 44 ], function( value ) {
			 *			return value &gt; 10;
			 *		} );
			 *		console.log( every );
			 *		// Logs: true
			 *
			 * @param {Array} array
			 * @param {Function} fn A function that gets called with each `array` item.
			 * @param {Mixed} fn.value The currently iterated array value.
			 * @param {Number} fn.index The index of the currently iterated value in an array.
			 * @param {Array} fn.array The original array passed as the `array` variable.
			 * @param {Mixed} [thisArg=undefined] A context object for `fn`.
			 * @returns {Boolean} Information whether all elements pass the test.
			 * @member CKEDITOR.tools.array
			 * @since 4.8.0
			 */
			every: function( array, fn, thisArg ) {
				// Empty arrays always return true.
				if ( !array.length ) {
					return true;
				}

				var ret = this.filter( array, fn, thisArg );

				return array.length === ret.length;
			}
		},

<span id='CKEDITOR-tools-property-object'>		/**
</span>		 * A set of object helpers.
		 *
		 * @property {CKEDITOR.tools.object}
		 * @member CKEDITOR.tools
		 */
		object: {
<span id='CKEDITOR-tools-object-method-findKey'>			/**
</span>			 * Returns the first key from `obj` which has a given `value`.
			 *
			 * @param {Object} obj An object whose `key` is looked for.
			 * @param {Mixed} value An object&#39;s `value` to be looked for.
			 * @returns {String/null} Matched `key` or `null` if not found.
			 * @member CKEDITOR.tools.object
			 */

			findKey: function( obj, value ) {
				if ( typeof obj !== &#39;object&#39; ) {
					return null;
				}

				var key;

				for ( key in obj ) {
					if ( obj[ key ] === value ) {
						return key;
					}
				}

				return null;
			},

<span id='CKEDITOR-tools-object-method-merge'>			/**
</span>			 * Merges two objects and returns the new one.
			 *
			 *		var obj1 = {
			 *				a: 1,
			 *				conflicted: 10,
			 *				obj: {
			 *					c: 1
			 *				}
			 *			},
			 *			obj2 = {
			 *				b: 2,
			 *				conflicted: 20,
			 *				obj: {
			 *					d: 2
			 *				}
			 *			};
			 *
			 *		CKEDITOR.tools.object.merge( obj1, obj2 );
			 *
			 * This code produces the following object:
			 *
			 *		{
			 *			a: 1,
			 *			b: 2,
			 *			conflicted: 20,
			 *			obj: {
			 *				c: 1,
			 *				d: 2
			 *			}
			 *		}
			 *
			 * @param {Object} obj1 The source object which will be used to create a new base object.
			 * @param {Object} obj2 An object whose properties will be merged into the base one.
			 * @returns {Object} The merged object.
			 * @member CKEDITOR.tools.object
			 */
			merge: function( obj1, obj2 ) {
				var tools = CKEDITOR.tools,
					copy1 = tools.clone( obj1 ),
					copy2 = tools.clone( obj2 );

				tools.array.forEach( tools.objectKeys( copy2 ), function( key ) {
					if ( typeof copy2[ key ] === &#39;object&#39; &amp;&amp; typeof copy1[ key ] === &#39;object&#39; ) {
						copy1[ key ] = tools.object.merge( copy1[ key ], copy2[ key ] );
					} else {
						copy1[ key ] = copy2[ key ];
					}
				} );

				return copy1;
			}
		}
	};

	// Generates a CSRF token with a given length.
	//
	// @since 4.5.6
	// @param {Number} length
	// @returns {string}
	function generateToken( length ) {
		var randValues = [];
		var result = &#39;&#39;;

		if ( window.crypto &amp;&amp; window.crypto.getRandomValues ) {
			randValues = new Uint8Array( length );
			window.crypto.getRandomValues( randValues );
		} else {
			for ( var i = 0; i &lt; length; i++ ) {
				randValues.push( Math.floor( Math.random() * 256 ) );
			}
		}

		for ( var j = 0; j &lt; randValues.length; j++ ) {
			var character = tokenCharset.charAt( randValues[ j ] % tokenCharset.length );
			result += Math.random() &gt; 0.5 ? character.toUpperCase() : character;
		}

		return result;
	}

<span id='CKEDITOR-tools-array-method-indexOf'>	/**
</span>	 * @member CKEDITOR.tools.array
	 * @method indexOf
	 * @inheritdoc CKEDITOR.tools#indexOf
	 */
	CKEDITOR.tools.array.indexOf = CKEDITOR.tools.indexOf;

<span id='CKEDITOR-tools-array-method-isArray'>	/**
</span>	 * @member CKEDITOR.tools.array
	 * @method isArray
	 * @inheritdoc CKEDITOR.tools#isArray
	 */
	CKEDITOR.tools.array.isArray = CKEDITOR.tools.isArray;

<span id='CKEDITOR-property-MOUSE_BUTTON_LEFT'>	/**
</span>	 * Left mouse button.
	 *
	 * @since 4.7.3
	 * @readonly
	 * @property {Number} [=0]
	 * @member CKEDITOR
	 */
	CKEDITOR.MOUSE_BUTTON_LEFT = 0;

<span id='CKEDITOR-property-MOUSE_BUTTON_MIDDLE'>	/**
</span>	 * Middle mouse button.
	 *
	 * @since 4.7.3
	 * @readonly
	 * @property {Number} [=1]
	 * @member CKEDITOR
	 */
	CKEDITOR.MOUSE_BUTTON_MIDDLE = 1;

<span id='CKEDITOR-property-MOUSE_BUTTON_RIGHT'>	/**
</span>	 * Right mouse button.
	 *
	 * @since 4.7.3
	 * @readonly
	 * @property {Number} [=2]
	 * @member CKEDITOR
	 */
	CKEDITOR.MOUSE_BUTTON_RIGHT = 2;

<span id='CKEDITOR-tools-style'>	/**
</span>	 * The namespace containing functions to work on CSS properties.
	 *
	 * @since 4.6.1
	 * @class CKEDITOR.tools.style
	 */

<span id='CKEDITOR-tools-style-parse'>	/**
</span>	 * The namespace with helper functions to parse some common CSS properties.
	 *
	 * @since 4.6.1
	 * @class CKEDITOR.tools.style.parse
	 */

<span id='CKEDITOR-tools-array'>	/**
</span>	 * The namespace with helper functions and polyfills for arrays.
	 *
	 * @since 4.6.1
	 * @class CKEDITOR.tools.array
	 */

<span id='CKEDITOR-tools-object'>	/**
</span>	 * The namespace with helper functions and polyfills for objects.
	 *
	 * @since 4.7.1
	 * @class CKEDITOR.tools.object
	 */
} )();

// PACKAGER_RENAME( CKEDITOR.tools )
</pre>
</body>
</html>
